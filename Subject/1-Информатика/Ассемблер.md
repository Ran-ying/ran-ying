
# Архитектура x86. Ассемблер NASM

## Регистры x86-64

- 8 "старых" регистров как бы общего назначения
    - rax
    - rbx
    - rcx
    - rdx
    - rbp
    - rsp
    - rsi
    - rdi
- 8 "новых" регистров общего назначения
    - r8
    - r9
    - r10
    - r11
    - r12
    - r13
    - r14
    - r15
- регистр-указатель команд
    - rip
- регистр флагов
    - CF
    - PF
    - AF
    - ZF
    - SF
    - OF

## Получить ассемблерный код для программы на С

```
gcc -S hello.c
```

## Собрать ассемблерный код с помощью gcc

```
gcc –o hello2 hello.s
```

## Как узнать номер системного вызова?

Можно использовать магию:

```
$ printf SYS_xxx | gcc -include sys/syscall.h –E - | 
grep -v '#'
```

## write()

```C
#include <unistd.h>
ssize_t write(
    int fd, // первый аргумент 
    const void *buf, // второй
    size_t count
); // третий
```

- fd – дескриптор файла:
    - 0 – стандартный поток ввода
    - 1 – стандартный поток вывода
- buf – указатель на буфер с данными: 
    в нашем случае - на строку
- count – количество байтов в буфере
    в нашем случае - длина строки

## Заготовка программы на ассемблере

```ASM
            global _start   ; точка входа
                            ; в программу

            section .text
_start:     ; тут будет наш код

            section .data
            ; тут будут данные и 
            ; определения констант

            section .bss
```

## Соглашения о вызовах aka calling conventions

Соглашения о вызовах определяют порядок передачи аргументов в функции. Для системных вызовов в ОС Linux используется следующее соглашение о вызовах:

Вход:

- rax номер системного вызова
- rdi первый аргумент
- rsi второй аргумент
- rdx третий аргумент
- r10 четвертый аргумент
- r8 пятый аргумент
- r9 шестой аргумент

Выход:

- rax результат вызова (отрицательное значение – ошибка)

## Почти работающий хеллоуворлд

```
            global _start

            section .text
_start:     mov rax, sys_write
            mov rdi, 1 ; 1 = stdout
            mov rsi, msg
            mov rdx, msg_len
            syscall

            section .data
msg         db      'Hello, world!', 10
msg_len     equ     $ - msg
sys_write   equ   1
```

## Программу требуется корректно завершить

```
; ...
            mov rax, sys_exit
            xor rdi, rdi    ; exit code 0
            syscall

            section .data
; ...
sys_exit    equ    60
```

## Как получить исполняемый файл?

- Сначала нужно выполнить ассемблирование файла с исходным текстом с помощью ассемблера NASM и получить в результате объектный файл:

```
$ nasm -felf64 hello.S
```

- После этого с помощью системного редактора связей превратить объектный файл в исполняемый файл:

```
$ ld -o hello hello.o
```

- Можно сделать все одной командой:

```
$ nasm -felf64 hello.S && ld -o hello hello.o
```

# Архитектура x86. Ассемблер NASM. Основные команды. Отладка

## Функциональная классификация команд

    основные команды процессора можно поделить на несколько групп:
    - пересылки данных
        - общего назначения
        - работы со стеком
    - арифметические
        - двоичной арифметики
        - десятичной арифметики
    - логические
    - передачи управления
    - цепочечные
    - управления состоянием ЦП

## Команды пересылки данных

- mov <DST>, <SRC>

```
mov rax, rbx ; из регистра в регистр
mov rax, 0xFF ; непосредственный операнд
mov rax, [0xFF] ; из памяти в регистр
mov rax, [rax] ; косвенная адресация
mov [rax], [rbx] ; так не получится
```

- xchg <OP1>, <OP2>

```
xchg rbx, rax ; обменять два регистра
xchg rax, [rbx] ; обменять регистр и память
xchg [rbx], [rax] ; это тоже не сработает
```

## Операнды-адреса

В общем случае, допустимы следующие варианты задания адреса в командах, где одним из операндов может быть адрес памяти:

```
[offset] ; смещение задано константой
[reg] ; смещение задано в регистре
[offset + reg] ; сумма смещения и регистра
[offset + reg*scale] ; scale = 1, 2, 4 или 8
[offset + reg + reg*scale]
```

Примеры:

```
mov rax, [0xffee]
mov rax, [array + rbx]
```

## Арифметические команды

- add <OP1>, <OP2>
    add rax, 3 ; сложение
- sub <OP1>, <OP2>
    sub rax, rbx ; вычитание
- inc <OP>
    inc rax ; инкремент
- dec <OP>
    dec qword [rax] ; декремент
- neg <OP>
    neg rax ; изменение знака
- cmp <OP1>, <OP2>
    cmp rax, rbx ; сравнение (вычитание без сохранения)
- mul <OP>
    mul rdx ; умножение беззнаковое
- imul <OP>
    imul qword [rdx] ; умножение знаковое
- div <OP>
    div rbx ; деление беззнаковое
- idiv <OP>
    idiv rbx ; деление знаковое

## Логические команды

- not <OP>
    not rax ; поразрядное НЕ
- or <OP1>, <OP2>
    or rax, rbx ; поразрядное ИЛИ
- and <OP1>, <OP2>
    and rax, [rbx] ; поразрядное И
- xor <OP1>, <OP2>
    xor rax, rax ; поразрядное исключающее ИЛИ
- test <OP1>, <OP2>
    test rax, rbx ; поразрядное И без сохранения результата (но с установкой флагов)

## Операции сдвига

- shl <OP>, N
    shl rax, 10 ; сдвиг влево
- shr <OP>, N
    shr dword [rax], 10 ; сдвиг вправо
- sar <OP>, N
    sar rax, 1 ; арифметический сдвиг вправо
- rol <OP>, N
    rol rax, 2 ; циклический сдвиг влево
- ror <OP>, N
    ror rax, cl ; циклический сдвиг вправо

Вместо N можно использовать регистр cl (и только этот регистр!)

## Команды передачи управления

- jmp <ADDR>
    jmp loop_beg ; безусловный переход
    jmp [rax] ; переход на адрес, содержащийся в регистре rax

## Флаги в регистре rflags

Флаги:
- CF
- ZF
- SF
- OF

## Команды передачи управления
- j??? <ADDR> ; условный переход, если...
    - jz, js, jc, jo ; установлен флаг
    - jnz, jns, jnc, jno ; НЕ установлен флаг
    - je ; операнды равны
    - jne ; операнды НЕ равны
    [для чисел со знаком]
    - jl, jnge ; меньше
    - jle, jng ; меньше или равно
    - jg, jnle ; больше
    - jge, jnl ; больше или равно
    [для чисел без знака]
    - jb, jnae ; меньше
    - jbe, jna ; меньше или равно
    - ja, jnbe ; больше
    - jae, jnb ; больше или равно

## Как получить случайное число?

- можно использовать пару библиотечных функций srand() и rand()

```C
srand(time(NULL));
int n = rand() % 16;
```

- на x86-64 можно использовать инструкцию rdrand

```
rdrand rax
and rax, 0xf
mov [n], rax
```

## Цепочечные (строковые) инструкции
- используют регистры rsi, rdi, rcx, rax и флаг DF
    - stosb/stosw/stosd/stosq
    - lodsb/lodsw/lodsd/lodsq
    - movsb/movsw/movsd/movsq
    - cmpsb/cmpsw/cmpsd/cmpsq
    - scasb/scasw/scasd/scasq
- могут использоваться либо в цикле, либо с префиксами повторения
- направление работы определяется флагом DF
    - std ; установка DF = адреса уменьшаются
    - cld ; сброс DF = адреса увеличиваются


# Занятие 5 NASM

## Ассемблирование:

```CMD
nasm -f <format> <имя_файла.asm> [-o <объектный_файл>]
```

Формат выходных файлов:
- elf
- bin
- obj
- coff
- ... (их много)

Часто используется формат elf

## Компановка

Компановщик – ld ([эль-дэ]).

ld prog_nasm2.o –o prog_nasm2

# Занятие 6

## Блок-схемы

- Руководящий документ:
    - ГОСТ 19.701-90 (ИСО 5807-85)

- Основные элементы блок-схем:
    - Процесс
    - Данные
    - Решение
    - Границы цикла
    - Подготовка
    - …

## Блок-схемы. Основные элементы

| Элемент       | Обозначение | Суть
|---------------|-------------|-------------------------------------------------------|
| Процесс       | 矩形           | Обработка данных (вычисления и т.д.)
| Терминатор    | 圆角矩形          | Начало и завершение программы
| Данные        | 平行四边形           | Операции ввода и вывода данных
| Решение       | 菱形            | Ветвления, выбор (в нашем случае – условный оператор)
| Границы цикла | ![](https://www.ranying.xyz/api/imageBed/i/2021/12/21/2ez2g3.jpg)        | Подходят для любых циклов
| Подготовка    | 六边形            | Счётные циклы (цикл for)

## Assembler

- Достоинства:
    - Возможность сделать программу более эффективной
    - Возможность получения прямого доступа к аппаратным средствам
    - Возможность лучше понять принципы работы программы
- Недостатки:
    - Непривычность
    - Могут возникать проблемы с переносимостью на компьютеры с другой архитектурой

## Assembler. Регистры


- Регистров - ограниченное количество
- Часто используются для краткосрочного хранения данных
- Нужные нам виды регистров:
    - Регистры общего назначения (РОНы)
        - Могут быть 1-байтными, 2-байтными, 4-байтными,…
        - Могут разделяться на части, которые тоже являются регистрами
        - Выполняются в арифметических, логических, … операциях
        - «Старые» регистры (не совсем) общего назначения

        | 32 бита | 64 бита | Составные части 64-битных регистров
        |---------|---------|-------------------------------------|
        | eax     | rax     | eax, ax, ah, al
        | ebx     | rbx     | ebx, bx, bh, bl
        | ecx     | rcx     | ecx, cx, ch, cl
        | edx     | rdx     | edx, dx, dh, dl
        | esi     | rsi     | esi, si
        | edi     | rdi     | edi, di
        | ebp     | rbp     | ebp, bp
        | esp     | rsp     | esp, sp


        - «Новые» регистры Assembler x86-64 общего назначения

        | Регистр	Составные части регистра |      |
        |----------------------------------|------|------|
        | r8	r8d                           | r8w  | r8b
        | r9	r9d                           | r9w  | r9b
        | r10	r10d                         | r10w | r10b
        | r11	r11d                         | r11w | r11b
        | r12	r12d                         | r12w | r12b
        | r13	r13d                         | r13w | r13b
        | r14	r14d                         | r14w | r14b
        | r15	r15d                         | r15w | r15b


    - Специальные регистры	

        - Регистр флагов (rflags)
            - CF
            - SF
            - ZF
            - OF
            - …

        - Регистр счётчика команд (rip): 64 бита
            - eip: 32 бита
            - ip: 16 бит

## Assembler. Hello World

```ASM
            global _start
            section .text
_start:     mov rax, sys_write
            mov rdi, 1              ; 1 = stdout
            mov rsi, msg
           	mov rdx, msg_len
            syscall
            mov rax, sys_exit
            xor rdi, rdi            ; exit code
            syscall
            
            section .data
msg         db      'Hello, world!', 10 ; 10 – символ перевода строки
msg_len     equ     $ - msg ; $ - последний байт строки msg
sys_write   equ     1
sys_exit    equ     60
```

## Assembler. Секции

- Ключевое слово – section
- Секция кода (.text)
- Сегмент данных
    - Секция данных (.data)
    - Секция неинициализированных данных (.bss)
- Секция стека

## Assembler. Выделение памяти

- Директивы задания исходных данных:
    - db – 1 байт
    - dw – 1 слово (2 байта)
    - dd – 1 двойное слово (4 байта)
    - dq – 1 учетверённое слово (8 байт)
    - dt – 10 байт

- Пример:

```
variable dq 1234321 ; задана восьмибайтная переменная variable, 		           ; равная 1234321
Имена переменных – по сути, метки!
```

## Assembler. Выделение памяти

- Директивы инициализирования неинициализированной памяти:

    - resb    ;Резервирование 1 байта
    - resw   ;Резервирование 1 слова (2 байт)
    - resd    ;Резервирование 1 двойного слова (4 байт)
    - resq    ;Резервирование 1 учетверённого слова (8 байт)
    - rest     ;Резервирование 10 байт

- Пример:
    - x resw 100 ; по адресу, связанному с меткой x, расположен	        ; массив из 100 2-байтовых ячеек

## Assembler. Задание чисел в разных системах счисления

- Запись числа в двоичной системе счисления:
    - Суффикс b (например, 010111101b)
- Запись числа в восьмеричной системе счисления:
    - Суффиксы q или o (например, 347o или 2137q)
- Запись числа в шестнадцатеричной системе счисления:
    - Суффикс h, или префикс $, или префикс 0x (например, 3746h или $234 или 0x8AF3)

## Assembler. Инициализация переменных

- В Assembler имя переменной – по сути, метка, ссылающаяся на начало какой-то области памяти 

section .data
a     dw      ‘AbraCadabra', 10
b     equ     100
c     db     1
d     dq     0x0ABCD123

## Assembler. Задание чисел в разных системах счисления

В Assembler запись числа всегда начинается с цифры!

- Правильно: 0x0F12D, $0DEADBEEF, 0xA2B3C1D, 0D12BA7h

- Ошибка: $D102D3A, AB15CDh

## Assembler. Команда mov

Выполняет копирование данных из одного места в другое

- Пример: mov eax, ecx

- eax – куда будут занесены данные
- ecx – откуда будут занесены данные 

## Assembler. Операнды

Виды операндов

- Регистровые операнды (rax, rbx, …)
- Непосредственные операнды (54, 0x0AB, operand, x)
- Операнды типа «память» (адресные операнды) ([x], [operand], [rax])

## Assembler. Адресация

Виды адресации

- Прямая
    - Берётся содержимое регистра/переменной
    - mov rax, rbx
- Косвенная
    - Содержимое регистра/переменной используется в качестве адреса
    - mov rax, [rbx]

## Assembler. Размеры операндов

- Размеры регистровых операндов задавать не нужно!

- Для операндов типа «память» используются спецификаторы размера:
    - byte
    - word
    - dword
    - …
- Примеры:
    - mov byte [a], 100
    - mov [d], word 1000

## Assembler. Возможные комбинации операндов


Допустимые комбинации операндов команды mov
	mov eax, ebx
	mov rax, 0x0A
	mov eh, 12
	mov [address], r10w
    mov r10w, [address]

Недопустимые комбинации операндов команды mov
	mov [address1], [address2]
	
    mov x, rax
	mov  5, rcx
	
    mov [vr], 120      ; правильный вариант:     mov [vr], word 120
			        ; или: mov word [vr], 120

## Assembler. Арифметические операции с целыми числами

- Сложение
    - add eax, ebx
    - add [variable1], edx

- Вычитание
    - sub rax, rbx
    - sub rcx, [variable2]

## Assembler. Сложение и вычитание с переносом

Учитывается значение флага CF

- Сложение с переносом
    - adc eax, edx
    - adc [variable1], edx

- Вычитание с переносом
    - sbb rсx, rbx
    - sbb rbx, [variable2]

## Assembler. Целочисленное умножение и деление

- Умножение
    - Беззнаковое: mul 
        mov ex, 10
        mov r8w, 20
        mul r8w
    - Со знаком: imul
        mov ex, -10
        mov r12w, 20
        imul r12w

- Деление
    - Беззнаковое: div 
        mov eax, 110
        mov r9d, 20
        div r9d
    - Со знаком: idiv
        mov eax, 120
        mov r8d, -30
        idiv r8d

## Assembler. Другие полезные команды


- cmp – сравнение двух операндов
    - cmp eax, ebx
- inc – инкремент
    - x db 0
inc x
- dec – декремент
    - y db 100
dec y
- neg – изменение знака числа
    - t db 100
neg t

## Assembler. Переходы

- Условные
    - Проверяется тот или иной флаг, полученный после выполнения какой-либо операции. Если значение этого флага равно 1, осуществляется переход по заданному адресу (часто – по метке)

- Безусловный
    - Переход на заданный адрес (метку) осуществляется гарантированно, без всякой проверки


- Безусловный переход: 
    - jmp
- Условные переходы (j (+ <not>) + <флаг>): 
    - jz (ZF = 1)
    - js (SF = 1)
    - jc (CF = 1)
    - jnz (ZF = 0)
    - jnc (CF = 0)
    - …

## Assembler. Переходы по результатам сравнения

Беззнаковые числа

| Переход | Назначение
|---------|------------------------------------------------|
| jg      | Переход, если первый операнд > второго
| jge     | Переход, если первый операнд >= второму
| jl      | Переход, если первый операнд < второго
| jle     | Переход, если первый операнд <= второму
| jng     | Переход, если первый операнд не больше второго
| jnge    | Переход, если первый операнд < второго
| jnl     | Переход, если первый операнд не меньше второго
| jnle    | Переход, если первый операнд > второго

Числа со знаком

| Переход | Назначение
|---------|------------------------------------------------|
| ja      | Переход, если первый операнд > второго
| jae     | Переход, если первый операнд >= второму
| jb      | Переход, если первый операнд < второго
| jbe     | Переход, если первый операнд <= второму
| jna     | Переход, если первый операнд не больше второго
| jnae    | Переход, если первый операнд < второго
| jnb     | Переход, если первый операнд не меньше второго
| jnbe    | Переход, если первый операнд > второго

## Assembler. Циклы

- Способ 1

mov r8b, 0
mov r10b, 10
lp1: 	;…
	inc r8b                ;  или dec r10b   
	cmp r10b, r8b
	jne lp1
	
- Способ 2

    - Использование команды loop
        mov ecx, 10
        lp1: 	;…
            loop lp1

    - У команды loop есть некоторые ограничения	

## Assembler. Побитовые операции

- and – побитовое «И»
    - and rax, rbx
- or – побитовое «ИЛИ»
    - or bx, dx
- xor – исключающее «ИЛИ»
    - xor eax, eax     ; обнуление значения eax
- not – побитовое отрицание
    - not si

## Assembler. Побитовые сдвиги

- Простой побитовый сдвиг
    - shr – простой побитовый сдвиг вправо
        - shr eax, 2
    - shl – простой побитовый сдвиг влево
        - shl eax, 8
- Арифметический сдвиг
    - sal – арифметический сдвиг влево
    - sar – арифметический сдвиг вправо
- Циклический сдвиг
    - ror (циклический сдвиг вправо)
        - ror el, 1
    - rol (циклический сдвиг влево)
        - rol eh, 2
- И некоторые другие сдвиги

# Занятие 7

## Assembler. Целочисленное умножение и деление

- Умножение
    - Беззнаковое: mul 
        mov ax, 10
        mov r8w, 20
        mul r8w
    - Со знаком: imul
        mov ax, -10
        mov r12w, 20
        imul r12w

- Деление
    - Беззнаковое: div 
        mov eax, 110
        mov r9d, 20
        div r9d
    - Со знаком: idiv
        mov eax, 120
        mov r8d, -30
        idiv r8d

## Assembler. Очень простая программа

Найти десятое число Фибоначчи

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …	
	mov r8b, 0
	mov r9b, 1
	mov cx, 9
	lp_fib: 
		add r8b, r9b
		mov r10b, r9b
		mov r9b, r8b
		mov r8b, r10b
		loop lp_fib

## Assembler. Вывод на печать

- Язык C:

```
int main()
{
	printf(“%d”, fib_10);
}
```

- NASM:

В явном виде универсальной команды, которая выводила бы на печать любое значение, не существует
	
- Посимвольный (поразрядный) вывод на печать
    - Регистры

- Системные вызовы (прерывания)
    - int … (например, int 80h)

- Системные вызовы
    - syscall

- Использование макросов из файла (stud_io.inc)

## Assembler. Прерывания

- Виды прерываний
    - Аппаратные
    - Программные
- Вызов программного прерывания:
    - int x, x – номер обработчика прерывания
    - 0 <= x <= 255
- Суть:
    - Пользователь передаёт управление ядру, с целью выполнения тех или иных действий

- Необходимые регистры для корректной работы команды int
    - rax
        - Номер системного вызова
    - rbx
        - Номер потока ввода/вывода
    - rcx
        - Вводимое/выводимое значение
    - rdx
        - Длина ввода/вывода

Значения регистров при вводе и выводе

| Регистр | Консольный ввод | Вывод на консоль
|---------|-----------------|------------------|
| rax     | 3               | 4
| rbx     | 2               | 1

Значения регистров rcx и rdx – сообщение, которое будет выведено на экран и его длина (в байтах) соответственно

- Пример ввода числа с клавиатуры

```
section .text
	global _start
_start:
	mov eax, 3
	mov ebx, 2
	mov ecx, num
	mov edx, 5
	int 80h
	…
section .bss
	num resb 5
```

- Пример вывода числа на консоль

section .text
	global _start
_start:
	mov eax, 4
	mov ebx, 1
	mov ecx, Text
	mov edx, lenText
	int 80h
	…
section .data
	Text db “AbraCababra!!!”, 10
	lenText db $ - Text

## Assembler. Syscall

- Таблица системных вызовов

https://filippo.io/linux-syscall-table/

Необходимые регистры для корректной работы syscall

- rax
    - Номер системного вызова
- rdi
    - Номер потока ввода/вывода
- rsi
    - Вводимое/выводимое значение
- rdx
    - Длина ввода/вывода

Значения регистров при вводе и выводе

| Регистр | Консольный ввод | Вывод на консоль
|---------|-----------------|------------------|
| rax     | 0               | 1
| rdi     | 1               | 1

Значения регистров rsi и rdx – сообщение, которое будет выведено на экран и его длина (в байтах) соответственно

Пример ввода числа с клавиатуры

section .text
	global _start
_start:
	mov eax, 0
	mov rdi, 1
	mov rsi, num
	mov edx, 5
	syscall
	…
section .bss
	num resb 5

Пример вывода числа на консоль

section .text
	global _start
_start:
	mov eax, 1
	mov rdi, 1
	mov rsi, Text
	mov edx, lenText
	syscall
	…
section .data
	Text db “AbraCababra!!!”, 10
	lenText db $ - Text

## Assembler. Посимвольный вывод значения регистра


- Причины
    - Надёжность (и контролируемость) работы
    - Реализация с небольшими изменениями под конкретную ситуацию
    - Возможность лучше понять принципы работы операторов вывода
    - Just for fun

- Недостатки
    - Не самая высокая эффективность
    - Представленный далее вариант «заточен» на числа размером до 16 бит.

Задача: Вывести на экран результат сложения двух чисел 

Общий алгоритм
Объявление переменных

section .data
	x dw 0		; длина числа (количество разрядов)
	n dw 10		; основание системы счисления
	c dw 0		; переменная, в которой хранится число
	m1 db 1	; переменная, в которой хранится разряд числа
	ms_e db 10	; номер символа «перенос строки» в таблице 				; ASCII


Общий алгоритм
Разбиение числа на разряды

section .text
	;…..
	mov r8w, 100		
	mov r9w, 50
	add r8w, r9w		; вычисление суммы двух чисел
	mov [c], r8w
	mov dx, 0
	mov ax, [c]
	lp1:			; занесение цифр в стек
		div word [n]
		push dx
		inc word [x]
		mov dx, 0
		sub ax, 0
		jnz lp1		; пока не будет занесено всё число	


Общий алгоритм
Вывод полученных разрядов числа на экран (в правильном порядке)

lp2:	pop r10w		; извлечение цифр из стека
	add r10w, 48		; перевод символов в цифры
	mov [m1], r10b		
	dec word [x] 
	mov     rax, 1    		
	mov     rdi, 1  
	mov     rsi, m1 
	mov     rdx, 1  
	syscall         		; вывод на экран
	sub word [x], 0		; проверка конца цикла
	jnz lp2	
mov     rsi, ms_e         
mov     rdx, 1   
syscall         	


Общий алгоритм
Корректное завершение программы
	
	mov    eax, 60            
	xor     rdi, rdi        
	syscall 	

## Assembler. Работа со стеком

Стек

- Принцип LIFO (Last in – first out)

- Последний элемент, помещённый в стек, находится в вершине стека

- push
- pop

- Регистр, используемый для работы со стеком в NASM – RSP
- В регистре RSP хранится адрес вершины стека (адрес, по которому располагается последний занесённый в стек элемент)
- Занесение элемента в стек => адрес вершины (значение RSP) уменьшается
- Извлечение элемента из стека => адрес вершины (значение RSP) увеличивается


- Занесение элемента в стек (push)
    push ecx
    push x
    push word [x]

- Извлечение элемента из стека (pop)
    pop r10d
    pop word [x]
- При работе со стеком операнды должны иметь размер 2 байта, 4 байта или 8 байт!

## Дизассемблирование

- Инструментов для дизассемблирования – много

- Используем objdump

- objdump – инструмент исследования объектных файлов. Выводит подробную информацию, содержащуюся в объектном файле

- objdump встроен в ОС Linux, запуск – посредством терминала

Пример:
objdump -D -M Intel prog1

