# Введение в вычислительную технику и программирование


### Computer Science
- Теоретические дисциплины:
    - теория информации
    - теория алгоритмов и автоматов
    - теория вычислимости
    - теория компиляторов
    - дискретная математика
    - математическая логика
    - теория графов 
    - теория множеств

### Позиционные системы счисления

$$b_{m-1}b_{m-2}\cdots b_{1}b_{0} = b_{m-1}\cdot B^{m-1} + b_{m-2}\cdot B^{m-2} + b_{1}\cdot B + b_{0}\cdot B^{0} + $$

$b_{m-1}$ старший разряд
$b_{ 0 }$ младший разряд

### Перевод чисел из десятичной системы в двоичную

- python 进制转换

    ```Python
    >>> f'{137:b}'
    10001001
    >>> int(f'{137:b}'), 2)
    137
    ```

- 四种常见进制

    | dec | bin   | oct | hex |
    |-----|-------|-----|-----|
    | 1   | 0001  | 1   | 1   |
    | 2   | 0010  | 2   | 2   |
    | 3   | 0011  | 3   | 3   |
    | 4   | 0100  | 4   | 4   |
    | 5   | 0101  | 5   | 5   |
    | 6   | 0110  | 6   | 6   |
    | 7   | 0111  | 7   | 7   |
    | 8   | 1000  | 10  | 8   |
    | 9   | 1001  | 11  | 9   |
    | 10  | 1010  | 12  | A   |
    | 11  | 1011  | 13  | B   |
    | 12  | 1100  | 14  | C   |
    | 13  | 1101  | 15  | D   |
    | 14  | 1110  | 16  | E   |
    | 15  | 1111  | 17  | F   |
    | 16  | 10000 | 20  | 10  |

- 编码
    num| прямый код | обратный код | дополнительный код
    ---|------------|--------------|---------------------
    +3 | [0]0000011 | 00000011     | 00000011
    -3 | [1]0000011 | 11111100 +1→ | 11111101
    +0 | [0]0000000 | 00000000     | 00000000
    -0 | [1]0000000 | 11111111 +1→ | 00000000
    обл| 0~255      | -127~127     | -128~127

- Двоичная арифметика
    - сложение A+B
        - A + B
    - вычитание A-B
        - A + (B дополнительный код)

- Перенос и переполнение
    - беззнаковой - перенос
    - знаковой - переполнение

## Единицы измерения информации

- Количество информации
    - Информация – любые сведения о чем угодно
    -  Данные – представление информации в формализованном виде, пригодном для передачи и обработки
    -  Количество информации как мера уменьшения неопределенности знания $I = - \sum_{i=1}^NP_i\cdot \log_2P_i$

- Единицы измерения информации
    - бит (bit)
    - байт (byte, octet)
        - тетрада (nibble)
    - слово (word)
        - старший и младший байты
    - двойное слово (double word)
        - старшее и младшее слова
    - учетверенное слово (quad word)
        - старшее и младшее двойные слова
    - машинное слово

- Порядок хранения байтов в машинных словах
    -  big-endian (network order)
        - младший байт по большему адресу
        - 从高位到低位填充地址
    -  little-endian (host order)
        - младший байт по меньшему адресу
        - 从低位到高位填充地址

## Вычислительная техника

- "Закон" Мура
    - количество транзисторов в интегральных схемах увеличивается в 2 раза примерно каждые 18 месяцев

- Две формы представления информации
    - 连续 аналоговая (непрерывная)
        - в виде одного сигнала, сравнимого с заданной величиной:
        - в ЦВМ информация представлена в виде целых чисел
    - 离散 дискретная (цифровая)
        - в виде нескольких сигналов, представляющих отдельные разряды числа
        - в АВМ информация представлена в виде значений аналоговых физических величин (давления газа или жидкости, напряжения электрического тока)

## Принципы фон Неймана

- Принцип двоичной системы счисления
    -  c точки зрения затрат оборудования наиболее экономичной является система счисления с основанием e
    - схемотехнически бистабильные элементы дешевле тристабильных
    ![](https://www.ranying.xyz/api/imageBed/i/2021/09/22/xaj25o.jpg)

- Принцип программного управления
    - универсальность достигается за счет разделения оборудования и программы, то есть прикладные алгоритмы реализуются не в «железе», а с помощью «софта»
    - АЛУ(ЦПУ) выполняет операции, которые определяются набором команд (instruction set)

- Принцип хранимой программы
    - в начале работы программа загружается в оперативную память
    - оперативная память – массив двоичных разрядов
    - команды программы и данные хранятся в одном и том же адресном пространстве

- Принцип условного перехода
    - команды выбираются процессором из памяти последовательно
    - в системе команд присутствуют специальные команды, позволяющие изменить порядок выборки

- Архитектура фон Неймана
    - Память
    - Устройство ввода
    - Устройство вывода
    - Арифметико-Логическое Устройство
    - Устройство Управления

- Принципы фон Неймана
    - 程序控制 программного управления
    - 条件转换 условного перехода
    - 可存储的程序 хранимой программы
    - 层次分明的存储 иерархической организации памяти
    - 二进制计算系统 двоичной системы счисления

- Резюме
    - В вычислительной технике используются в основном двоичная и шестнадцатеричная системы счисления
    - Для измерения количества информации существуют различные подходы и специальные единицы
    - В современной вычислительной технике информация представляется в дискретной форме

# Аппаратные средства вычислительной техники и ассемблеры

## Процессоры

### Что собой представляет процессор (с точки зрения схемотехники)?
- если утрировать, то
    - любой процессор – просто огромная **логическая схема**, составленная из **логических элементов** (сумматоров, компараторов, триггеров, регистров)
    - логические элементы в свою очередь построены на основе транзисторов, инверторов, диодов, ...

### Как работает процессор?
- если упрощенно, то 
    - каждый раз, когда на вход поступает **тактирующий импульс**, в процессоре переключается состояние логических элементов
    - частота тактирующих импульсов (**тактовая частота**) определяет, как много переключений – и в конечном счете операций – в секунду может делать процессор

### Что собой представляет процессор?
- если утрировать, то 
    - любой процессор – просто "числодробилка" (number cruncher)
    - процессор хранит числа, с которыми выполняет операции, в регистрах

### Что собой представляет регистр?
- если утрировать, то 
    - регистр – ячейка памяти внутри процессора
    - наиболее часто на программном уровне приходится иметь дело с
        - регистрами общего назначения (РОНами)
        - регистром команд
        - регистром флагов

### Что собой представляет память?
- если говорить упрощенно, то 
    - память – это массив ячеек (обычно байтов), каждый байт имеет порядковый номер, который называется адресом
    - исполнение любой программы сводится к изменению состояния памяти от некоторого начального к некоторому конечному

### разрядность процессора определяет
- размер **машинного слова**
    - числа какой разрядности могут участвовать в основных арифметических/логических/... операциях
- размер **регистров общего назначения**
- разрядность шины данных
    - но это не всегда равная разрядности процессора величина, гораздо чаще кратная (x2, x4 и т.д.)
- объем непосредственно адресуемой памяти

### Система команд и архитектуры
- **система команд** процессора определяет операции, которые можно выполнять над данными и с помощью которых можно управлять поведением процессора
- **архитектура** процессора – набор свойств и качеств процессора, определяющий разрядность, систему команд и другие свойства
- **микроархитектура** процессора – реализация архитектуры с использованием конкретного техпроцесса и микроархитектурных решений

### Система команд и архитектуры
- CISC Complex Instruction Set Computer
    - IBM System 360, 370, z/Arcitecture
    - DEC PDP-11, VAX, ...
    - Intel x86, **x86-64**
- RISC Reduced Instruction Set Computer
    - 88000
    - PowerPC
    - SPARC
    - MIPS
    - **ARM**

### Как оценить производительность процессора?
- Пусть есть некоторый процессор, который выполняет программы, состоящие из инструкций, причем каждая инструкция выполняется за некоторое количество тактов (циклов)
- Введем обозначения:
    - P – 总代码量 общее количество выполненных программ
    - I – 总指令量 общее количество инструкций в программах
    - T – 完成时间 общее время выполнения программ
    - С – 总循环数 общее количество циклов, затраченное на выполнение программ

### Очень сложная и непонятная формула

$$\frac{T^{(1)}}{P} = \frac{T}{P}\cdot 1 = \frac{T}{P}\cdot\frac{I}{C}\cdot\frac{C}{I} = \frac{T^{(2)}}{C}\cdot\frac{I}{P^{(3)}}\cdot\frac{C}{I^{(4)}}$$

- $T^{(1)}$ - коэффициент производительности процессора
- $T^{(2)}$ - время одного такта (можно уменьшить, подняв частоту)
- $P^{(3)}$ - среднее количество инструкций в программе (можно уменьшить, добавляя в систему команд "сложные" команды)
- $I^{(4)}$ - $среднее количество тактов на одну команду
(можно уменьшить, упрощая команды)

### Исполнение команд
- В современных процессорах применяются разнообразные архитектурные решения для увеличения производительности:
    - конвейеризация (instruction pipelining)
    - предвыборка кода(prefetching)
    - предсказание ветвлений (branch prediction)
    - суперскалярность (superscalar architecture)


## Пример проектирования архитектуры процессора

### Очень простая задача

Необходимо создать систему контроля содержания кислорода в воздухе

- нормальное содержание по объему – 21%
- датчик записывает в заданный адрес памяти текущее значение
- есть возможность ввести с пульта
    - нормальное значение
    - максимально допустимое отклонение
- сигнал тревоги включается путем записи ненулевого значения в заданную ячейку памяти

### Очень простой процессор

- разрядность 
- объем непосредственно адресуемой памяти
- количество регистров и их назначение
- значения регистров после включения питания
- стартовый адрес
- система команд
    - коды операций
    - типы адресации
- представление чисел
    - разрядность
    - знак

![](https://www.ranying.xyz/api/imageBed/i/2021/10/06/vwikgp.jpg)

### Очень простая система команд

- какие операции поддерживаются?
    - пересылки данных
    - арифметические
    - передачи управления
    - еще какие-то?
- сколько нужно битов для хранения кода операции?
- какая дополнительная информация должна быть в каждой команде?

### структура команды

- 1 Байт

    |OPCODE|DST|SRC|
    |-|-|-|
    |7654|32|10|

- 2 Байт

    |OPCODE|DST|SRC|ADDR/CONST|
    |-|-|-|-|
    |7654|32|10|76543210|

### Команды пересылки данных

- из регистра в регистр

    |OPCODE|DST|SRC|
    |-|-|-|
    |0000|??|??|

    R0 <- R1 : 0000 00 01

- из памяти в регистр

    |OPCODE|DST|SRC|ADDR/CONST|
    |-|-|-|-|
    |0001|??|..|????????|

    R0 <- @0x0A : 0001 00 00 00001010

- из регистра в память

    |OPCODE|DST|SRC|ADDR/CONST|
    |-|-|-|-|
    |0010|..|??|????????|

    @0x0A <- R0 : 0010 00 00 00001010

- число в регистр

    |OPCODE|DST|SRC|ADDR/CONST|
    |-|-|-|-|
    |0011|??|..|????????|

    R2 <- 0x0A : 0011 10 00 00001010

### Арифметические команды

DST = DST ? SRC

арифметика|OPCODE|DST|SRC|
-|-|-|-|
сложение  |0100|??|??|
вычитание |0101|??|??|
умножение |0110|??|??|
деление   |0111|??|??|

### Команда сравнения

|OPCODE|DST|SRC|
|-|-|-|
|1000|??|??|

RF <- R0 ~ R1 : 1000 00 01
True : SRC > DST

### Команды перехода

RF: 

7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
--|---|---|---|---|---|---|--
. | . | . | . | . | C | S | Z

上一条命令的结果或者比较结果写入  
C: 进位（溢出为 1）  
S: 符号（负号为 1）  
Z: 零位（零为 1）  

- перейти, если есть перенос (RF.C = 1)

    |OPCODE|DST|SRC|ADDR/CONST|
    |-|-|-|-|
    |1001|..|..|????????|

    RC <- @0x80 (C) : 1001 0000 10000000

- перейти, если знак (RF.S = 1)

    |OPCODE|DST|SRC|ADDR/CONST|
    |-|-|-|-|
    |1010|..|..|????????|

    RC <- @0x80 (S) : 1010 0000 10000000

-  перейти, если ноль (RF.Z = 1)

    |OPCODE|DST|SRC|ADDR/CONST|
    |-|-|-|-|
    |1011|..|..|????????|

    RC <- @0x80 (Z) : 1011 0000 10000000

### Безусловный переход

|OPCODE|DST|SRC|ADDR/CONST|
|-|-|-|-|
|1100|..|..|????????|

RC <- @0x80 : 1100 0000 10000000

### Дополнительные команды

- случайное число в регистр

    |OPCODE|DST|SRC|
    |-|-|-|
    |1101|??|??|

    R1 <- ? : 1101 01 00

- инкремент

    |OPCODE|DST|SRC|
    |-|-|-|
    |1110|??|??|

    R1 <- R2++ : 1110 01 10
    (R2 не изменяется)

### Очень простая система команд

| index | assembler           | machine           |
|-------|---------------------|-------------------|
| 1     | Rdd <- Rss          | 0000ddss          |
| 2     | Rdd <- @aaaaaaaa    | 0001dd?? aaaaaaaa |
| 3     | @aaaaaaaa <- Rss    | 0010??ss aaaaaaaa |
| 4     | Rdd <- nnnnnnnn     | 0011dd?? nnnnnnnn |
| 5     | Rdd <- Rdd + Rss    | 0100ddss          |
| 6     | Rdd <- Rdd - Rss    | 0101ddss          |
| 7     | Rdd <- Rdd * Rss    | 0110ddss          |
| 8     | Rdd <- Rdd / Rss    | 0111ddss          |
| 9     | RF <- Rdd ~ Rss     | 1000ddss          |
| 10    | RC <- @aaaaaaaa (C) | 1001???? aaaaaaaa |
| 11    | RC <- @aaaaaaaa (S) | 1010???? aaaaaaaa |
| 12    | RC <- @aaaaaaaa (Z) | 1011???? aaaaaaaa |
| 13    | RC <- @aaaaaaaa     | 1100???? aaaaaaaa |
| 14    | Rdd <- ?            | 1101dd??          |
| 15    | Rdd <- Rss++        | 1110ddss          |

## Очень простой ассемблер для очень простого процессора

## Задача № 1

```
R0 <- ?
@0xFF <- R0


R0 <- @0xFF
R2 <- @0xFF
R1 <- 2
R0 <- R0 / R1
R0 <- R0 * R1
RF <- R0 ~ R2
RC <- @SET(S)
STOP: RC <- @STOP
SET: @0xFE <- R1
LAST: RC <- @LAST
```

## системы счисления

Систем счисления бесконечно много.
- Позиционные
- Непозиционные

Часто использующиеся:
- В жизни: десятичная
- В ЭВМ: двоичная, шестнадцатеричная, иногда - восьмеричная

Быстрый перевод чисел из двоичной системы счисления в любую другую с основанием, равным степени двойки, и наоборот.

## Количество и единицы измерения информации

- Наименьшая единица измерения информации – бит. 8 бит = 1 байт.
- Длина слова зависит от разрядности процессора и операционной системы.
- По умолчанию считаем его равным 16 бит. 1 тетрада – половина байта (4 бита).
- 1 Кбайт = 1024 байт = 2^10 байт.
- 1 Мбайт = 1024 Кбайт = 2^20 байт.
- 1 Гбайт = 1024 Мбайт = 2^30 байт.

## Прямой, обратный и дополнительный коды

- Прямой код
    - Старший разряд отводится под знак (0 – положительное, 1 - отрицательное).
    - В остальные разряды записывается модуль числа.
- Обратный код
    - Обратный код положительного числа равен его прямому коду. 
    - Обратный n-разрядный код отрицательного числа состоит из знакового бита, равного 1, а также (n – 1)-разрядного двоичного числа, равного инвертированному представлению его модуля.
- Дополнительный код
    - Дополнительный код положительного числа совпадает с его **прямым кодом**.
    - Дополнительный код отрицательного числа получается путём прибавления единицы к его **обратному коду**.
    - Другой способ получения дополнительного кода – 
вычитание **прямого кода** этого числа из **нуля**.

## Арифметические операции с двоичными числами. Флаги

- Для обеспечения выполнения всех операций в компьютере существует так называемый **регистр флагов**
- За каждым битом регистра флагов закреплено **обслуживание определённой операции**
- Примеры – флаг переноса (**CF**), нулевой флаг (**ZF**), 
флаг переполнения (**OF**), флаг знака (**SF**) и др.

https://simplecpu.online/

## Simple Assembler. Характеристики

Характеристики
- 15 команд
- 256 байт памяти (матрица 16x16 однобайтовых ячеек)
- 4 регистра общего назначения
- 2 специальных регистра
- Данные в памяти записываются в виде шестнадцатеричных чисел
- Среда написания программ: Блокнот/Wordpad/Notepad++

## Работа с командной строкой

- Запуск командной строки
    - ОС Windows: Меню «Пуск» -> cmd
    - ОС Linux: Терминал
- Важные команды
    - Переход на нужный диск
    - Переход в нужный каталог (папку)
        - cd путь_к_нужному_каталогу
        - Без русских букв!
    - Вызов справки
        - help

## Запуск виртуального микропроцессора

- регистр
    - **R0, R1, R2, R3** – регистры общего назначения
    - **RC** – регистр команд
    - **RF** – регистр флагов

- button
    - **Собрать!** – загрузка программы, компиляция и последующая сборка
    - **Шаг!** – следующий шаг выполнения программы
    - **Старт!** – запуск кода
    - **Сброс!** – начать работу программы заново

- Регистры и оперативная память
    - **Оперативная память** – это общая память компьютера, которая продаётся в магазинах (платы). 
    - **Регистры команд** – это процессорная память, располагается непосредственно в процессоре. 
    - В языках высокого уровня (C, Pascal и т.д.) пользователь имеет доступ только к **оперативной памяти**.
    - В языке Assembler и в SASM пользователь имеет доступ также к **регистрам команд**.

## Команды SASM

### Работа с памятью:

1. Запись данных из регистра в регистр (1 байт)
```
R01 <- R00
```
2. Запись данных из памяти в регистр (2 байта)
```
R00 <- @0x11
R01 <- @111
```
3. Запись данных из регистра в память (2 байта)
```
@0x11 <- R00
@111 <- R01
```
4. Запись числа в регистр (2 байта)
```
R00 <- 10
R00 <- 0x10
```

### Арифметические операции

Арифметические операции в SASM можно выполнять только с регистрами!

1. Сложение (прибавление) (1 байт)
```
R01 <- R01 + R00
```
2. Вычитание (убавление) (1 байт)
```
R03 <- R03 - R01
```
3. Умножение (домножение) (1 байт)
```
R02 <- R02 * R00
```
4. Деление (1 байт)
```
R00 <- R00 / R03
```

### Сравнение и переходы:

Основаны на работе с флагами

1. Сравнение значений в регистрах (1 байт)
```
RF <- R01 ~ R02
```
2. Условный переход по флагу переноса (CF) (2 байта)
```
RC <- @0xAB (C)
RC <- @100 (C)
```
3. Условный переход по флагу знака (SF) (2 байта)
```
RC <- @0xAB (S)
RC <- @100 (S)
```
4. Условный переход по флагу нуля (ZF) (2 байта)
```
RC <- @0xAB (Z)
RC <- @100 (Z)
```
5. Безусловный переход (2 байта)
```
RC <- @0xAB
RC <- @100
```

## Прочие команды
1. Занесение случайного числа в регистр (1 байт)
```
R01 <- ?
```
2. Инкремент значения регистра (1 байт)
```
R00 <- R00++
R01 <- R02++
```

## Команды SASM. Метки

- Программа без метки:

RC <- @12(S)
```
RC <- @12(S)
R00 <- R00 + R02
```

- Такая же программа с меткой:
```
RC <- @Label(S)
Label: R00 <- R00 + R02
```

## Работа в Simple CPU

**Ненулевые значения в матрице** – команды из скомпилированной программы.

**Полужирным шрифтом** в матрице выделены ячейки, которые соответствуют выполняемой на текущем шаге команде

## Сравнение SASM, Assembler, Pascal, C

- Занесение числа в память
    - SASM
    ```
    R00 <- 10
    @0xA0 <- R00
    ```
    - Assembler
    ```
    a1 resw 2
    ...
    mov ax, 10 
    mov [a1], ax
    ```
    - Pascal
    ```
    a := 10;
    ```
    - C
    ```
    a = 10;
    ```
- Прибавление одного числа к другому - Арифметические операции
    - SASM
    ```
    R00 <- 10
    R01 <- 5
    R00 <- R00 + R01
    @0xA0 <- R00
    ```
    - Assembler
    ```
    mov ax, 10
    mov cx, 5
    add ax, cx
    ```
    - Pascal
    ```
    a := 10;
    a := a + 5;
    ```
    - C
    ```
    a = 10;
    a += 5;
    ```
- Вычитание одного числа из другого - Арифметические операции
    - SASM
    ```
    R00 <- 10
    R01 <- 5
    R00 <- R00 - R01
    @0xA0 <- R00
    ```
    - Assembler
    ```
    mov ax, 10
    mov cx, 5
    sub ax, cx
    ```
    - Pascal
    ```
    a := 10;
    a := a - 5;
    ```
    - C
    ```
    a = 10;
    a -= 5;
    ```
- Умножение одного числа на другое - Арифметические операции
    - SASM
    ```
    R00 <- 10
    R01 <- 5
    R00 <- R00 * R01
    @0xA0 <- R00
    ```
    - Assembler
    ```
    mov ax, 10
    mov bx, 5
    mul bx
    ```
    - Pascal
    ```
    a := 10;
    a := a * 5;
    ```
    - C
    ```
    a = 10;
    a *= 5;
    ```
- Целочисленное деление одного числа на другое - Арифметические операции
    - SASM
    ```
    R00 <- 10
    R01 <- 5
    R00 <- R00 / R01
    @0xA0 <- R00
    ```
    - Assembler
    ```
    mov ax, 10
    mov bx, 5
    div bx
    ```
    - Pascal
    ```
    a := 10;
    a := a div 5;
    ```
    - C
    ```
    a = 10;
    a /= 5;
    ```
- Сравнение и передача управления
    - SASM
    ```
    RF <- R00 ~ R01
    RC <- @Label_1(S)
    ...
    RC <- @Label_2
    Label_1:
    ...
    Label_2:
    ```
    - Assembler
    ```
    sub ax, bx
    JA Label_1
    ...
    JMP Label_2
    Label_1: 
    ... 
    Label_2:
    ```
    - Pascal
    ```
    if (a > b) then
    begin
    ...
    end;
    else
    begin
    ...
    end;
    ```
    - C
    ```
    if a > b
    {
    ...
    }
    else
    {
    ...
    }
    ```

## SASM. Создание циклов

- Аналог цикла с предусловием (for или while):

```
R00 <- 0
R01 <- 10
R02 <- 1
LOOP: RF <- R00 ~ R01
 RC <- @END(Z)
 R00 <- R00++ 
 R02 <- R02++
 R02 <- R02++
 RC <- @LOOP
END: @0xFF <- R02
```

- Аналог цикла с постусловием (do...while()):

```
R00 <- 0
R01 <- 10
R02 <- 1
LOOP: R00 <- R00++ 
 R02 <- R02++
 R02 <- R02++
 RF <- R00 ~ R01
 RC <- @END(Z)
 RC <- @LOOP
END: @0xFF <- R02
```

# Парадигма и языки программирования

## Алгоритм

- Алгоритм – это…
    - точная последовательность действий для решения некоторой задачи за конечное время
    - последовательность действий, либо приводящая к решению задачи, либо поясняющая, почему это 
решение получить нельзя
-  Алгоритмам присущ ряд свойств:
    - дискретность
    - определенность
    - массовость
    - результативность

## Язык

-  Программа – алгоритм, записанный на некотором языке
- Язык
    - алфавит
    - грамматика
    - синтаксис
    - семантика
- Классификация языков по Хомскому
    - c фразовой структурой
    - контекстно-зависимые
    - контекстно-свободные
    - регулярные

- Парадигмы программирования
    - императивное программирование
        - большинство ЯВУ FORTRAN, Algol, C, Pascal/Oberon, …
    - объектно-ориентированное программирование
        - языки промышленного программирования Simula, Smalltalk, C++/C#, Ada, Java, Python, …
    - аппликативное программирование
        - языки "сверхвысокого" уровня LISP (INTERLISP, CLOS), Scheme, Arc, ML, Haskell, …
    - логическое программирование
        - языки ИИ Prolog, Planner, Oz, …
    - ... (парадигм много)

- Что влияет на популярность языка?
    - открытость стандарта
    - переносимость
        - поддержка производителями оборудования и крупными корпорациями
    - приспособленность для разработки крупных программных проектов
        - поддержка раздельной компиляции, модулей, библиотек
        - средства для взаимодействия с другими языками
        - удобный синтаксис, usability, look&feel, …
        - поддержка нескольких парадигм

- Что НЕ влияет на популярность языка?
    - производительность программ, написанных на этом 
    языке
        - Python, Java, VisualBasic, …
    - заложенные в язык идеи
        - LISP, SETL, APL, Smalltalk,…
    - «национальная поддержка»
        - РусФор, ГЛАГОЛ, ...
    - цена компиляторов и сред разработки
    - реклама (?)
        - Java, C#

- Ошибки
    - синтаксические
        - ошибки периода компиляции (compilation errors)
    - системные
        - ошибки периода редактирования связей (linking errors)
    - логические
        - ошибки времени исполнения (runtime errors)

# Язык C. Выражения, операции, операторы

## Компиляция из командной строки

- GNU Compiler Collection

> cc –o example example.с
> ./example
> gсс –o example example.c
> ./example

- LLVM

> clang –o example example.с
> ./example

## Справочная информация по С и С++

cppreference.com

## Получение случайных чисел в заданном диапазоне

```C
#ifdef _WIN32
#include <windows.h>
#define getpid GetCurrentProcessId
#else
#include <unistd.h>
#endif
srand(time(NULL) + getpid());
printf("%d", rand());
```

## Побитовые операции

x | y |~x |x\|y |x&y| x^y
--|---|---|-----|---|-
0 | 0 | 1 |  0  | 0 | 0
0 | 1 | 1 |  1  | 0 | 1
1 | 0 | 0 |  1  | 0 | 1
1 | 1 | 0 |  1  | 1 | 0

## Логические операции

x | y | !x | x\|\|y | x&&y
--|---|---|---|---
false | false | true  | false | false
false | true  | true  | true  | false
true  | false | false | true  | false
true  | true  | false | true  | true

## 位操作

- проверка

y = x & (1 << n)

- установка

x |= 1 << n

- сброс

x &= ~(1 << n)

- Инвертирование

x ^= 1 << n

- Сброс самого правого единичного бита

```C
unsigned int x = 42;
unsigned int m = 1;
if (x) {
    while (!(x & m)) m <<= 1; //теперь верно
    x &= ~m;
}
```

# Отладка программ

## Что такое отладчик
- Отладчик (debugger) – программа, которая 
позволяет выполнять другую программу в 
пошаговом режиме и наблюдать за состоянием 
памяти отлаживаемой программы
- Отладчик может быть интегрирован в среду 
разработки (Visual Studio, XCode) или поставляться 
отдельно (gdb, lldb)
- Отладку можно выполнять на уровне исходных 
кодов или машинных инструкций

## Отладчик gdb

- Основные команды:
    - help <cmd> – показать справку по cmd
    - break <func> – точка останова в func
    - run – запустить программу
    - next, step – выполнить следующую строку исходного кода
    - ni, si – выполнить следующую инструкцию
    - list – показать исходный код
    - disas /s – показать код+инструкции
    - frame – показать текущее положение
    - kill – остановить выполнение программы
    - quit – выход

# Вызов подпрограмм

## Операции со стеком

Стек – это область памяти в адресном пространстве процесса, которая используется для хранения активационных записей функций и локальных переменных

## Вызов и возврат из подпрограмм
- call <OP>
    - call 0x55004046 ; вызов по адресу 
    - call fib ; вызов по метке (адресу)
    - call [rax] ; вызов по адресу в регистре
- ret
    - ret ; извлечь из стека адрес возврата и выполнить переход по нему


# Занятие 3

## Выход за пределы байта

### Положительные числа.

```
R00 <- 250
R01 <- 100
R01 <- R01 + R00
```

250 + 100 = 350  
350(10) = 1 0101 1110 (2) = 0101 1110 (2)  
350(10) - 256(10) = 0101 1110 (2)

正数溢出减去 256

### Отрицательные числа.

```
R02 <- -150
R03 <- -120
R02 <- R02 + R03
```

-150 + (-120) = -270.  
-270 = 1111 1110 1111 0010 = 1111 0010 = 242

## SASM. Битовое представление команд

<table><tr><td colspan="3">Первый байт. Обязательный.</td><td>Второй байт. Есть не во всех командах</td></tr>
<tr><td>Номер команды. 4 бита</td><td>Куда (или 00). 2 бита</td><td>Откуда (или 00). 2 бита</td><td>Число / адрес ячейки</td></tr></table>

Если в битовом представлении команды есть «?», то вместо него записывается 0.

## SASM. Ошибки и предупреждения при компиляции

### Ошибки

Строка x: тип ошибки (x – номер строки)

- Неизвестная инструкция

Пример: R00 <- P00 + R01

- ‘ZZZ' выходит за пределы допустимого диапазона 

Пример: R00 <- 256

- Регистр назначения 'RXX' не совпадает с 'RYY' 

Пример: R02 <- R01 + R02

