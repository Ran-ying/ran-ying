---
layout: article
title:  "图论"
date: 2022-12-28 12:00:00 +0300
---

# Основы теории графов

## Понятие графа

Граф $G(X,U)$ - два множества $X$ и $U$, находящихся между собой в отношении инцидентности.

Множество вершин - $X = \{x_1, x_2, \cdots, x_n\}, X \neq \emptyset, \lvert X \rvert = n$.
Множество ребер и (или) дуг $U = \{u_1, u_2, \cdots, u_m\}, \lvert U \rvert = m$.
Размерность графа: `n,m-граф`

- Дуга: 单向弧
  - Дуги называются `кратными`, если они имеют общую вершину исхода и общую вершину захода: 多条共同传入顶点和共同传出顶点的弧
- Петля: 循环单向弧
- Ребро: 两条相反单向弧，或边
  - Ребра называются `кратными`, если они имеют общие концы: 多条共同端点的边

$\Gamma(x)$ - 与 $x$ 相连接的所有点

Математически любой n,m-граф можно представить в виде матрицы инцидентности А.

$\left\| A \right\| = n \times m$

Каждый столбец этой матрицы имеет ровно два ненулевых элемента.

- -1: вершина исхода дуги
- 1: вершина захода дуги

Замечу, что если в множестве U имеются только ребра, то каждый столбец такой матрицы имеет два ненулевых элемента, и они кодируются для концов этого ребра единицами.

## Классификация графов по структуре

### Неограф (неориентированный граф)

$G(X,U)$ - неограф (неориентированный граф), если $U$ - множество ребер.

Его матричное представление - это матрица связности размерностью $n \ast n$, в которой элемент матрицы на пересечении i-й строки и j-го столбца определяется количеством ребер, инцидентных вершинам $x_i$ и $x_j$.

Т.к. любое ребро является заменой двух встречных дуг, то и матрица связности неографа симметрична относительно главной диагонали этой матрицы.

`Локальная степень` (= `валентность`) вершины $x$ неографа $\rho(x)$ – числовая характеристика вершины, определяемая количеством инцидентных ей ребер.

$$
\begin{aligned}m&=\frac{\sum_{i=1}^n\rho(x_i)}{2}, \rho(x_i)=\sum_{i=1}^nb_{ij}=\sum_{j=1}^nb_{ji}\\
m&=\frac{\sum_{i=1}^n\sum_{j=1}^nb_{ij}}{2}\end{aligned}
$$

### Орграф (ориентированный граф)

$G(X,U)$ - орграф (ориентированный граф), если $U$ - множество дуг.

Полустепень захода, полустепень исхода вершины $x$ орграфа $\rho^+(x)$, $\rho^-(x)$– числовые характеристики вершины, определяемые количеством входящих, выходящих дуг.

- i-行数-入
- j-列数-出

$$
\begin{aligned}m&=\sum_{i=1}^n\rho^+(x_i)=\sum_{i=1}^n\rho^-(x_i)\\
\rho^-(x_i)&=\sum_{j=1}^nb_{ji}\\
\rho^+(x_i)&=\sum_{j=1}^nb_{ij}\end{aligned}
$$

Если орграф задан в виде матрицы В, то количество дуг в нем определяется как сумма элементов этой матрицы.

$$
m=\sum_{i=1}^n\sum_{j=1}^nb_{ij}
$$

### Граф со смешанной структурой

$G(X,U)$ - граф со смешанной структурой, если $U$ - множество ребер и дуг.

## Основной терминологический базис теории графов

### Псевдограф

**有所有类型的边**

Псевдограф - это обобщенное понятие бинарного графа.

Псевдограф может включать в себя все возможные элементы структуры: петли, дуги, ребра, кратные дуги, кратные ребра.

### Мультиграф

**没有循环的 Псевдограф**

Мультиграфом - псевдограф без петель.

Мультичисло графа - максимальное количество кратных ребер или дуг в этом графе.

### Скелетный граф

**мультичисло 为 1 的 Мультиграф**

Скелетный (обыкновенный, простой) граф - это мультиграф, в котором мультичисло равно единице, то есть это граф, в котором нет ни кратных ребер, ни кратных дуг, и отсутствуют петли.

### Пустой граф

**空图**

Пустой граф(0-граф) - это граф $G=(X,U)$, в котором множество U пустое.

### Полный граф

**满的没有循环的无向图**

Полный граф - это скелетный неограф, в котором каждая пара вершин соединена ребром.

Количество ребер в полном графе - $m=\frac{n\cdot (n-1)}{2}$.

Следовательно, задать полный граф легко. Для этого нужно только определить количество вершин n в нем.

### Насыщенный граф

**满的有循环的无向图**

Насыщенный граф – это полный граф, в котором при каждой вершине есть петля.

### Регулярный граф

**入度和出度处处相等的图**

Регулярный граф - это граф, в котором $\forall x \in X: \rho(x) = const$ или $\forall x \in X: \rho^+(x)=const, \rho^-(x)=const$

Замечу, что любой полный граф является регулярным графом, и локальная степень вершины в полном графе определяется как n-1, где n - это количество вершин в данном полном графе.

### Взвешенный граф

**加权图**

Взвешенный граф - это граф с числовыми характеристиками или весами у элементов множеств $X$ и/или $U$. Отсюда и название графа.

Математически взвешенный граф представляется в виде матрицы весов, каждый элемент в этой матрице определяется весом соответствующего ребра.

Бесконечное значение присваивается тем элементам матрицы, которые соответствуют отсутствующим ребрам в этом графе.

![](https://www.ranying.xyz/api/imageBed/i/2022/03/17/5a2r4y.jpg)

- U- множество псевдографов
- М – множество мультиграфов
- S – множество скелетных графов
- R – множество регулярных графов
- P – множество полных графов
- N – множество насыщенных графов

## Смежность в графах

**图的邻接关系**

Две вершины $x$ и $y$ называются смежными, если они являются концами одного и того же ребра или началом и концом одной и той же дуги.

Ребра называются смежными, если у них только один общий конец. В противном случае (если у них два общих конца), как мы уже знаем, ребра называются кратными.

Дуги называются смежными, если у них общая вершина стока (вершину конца или захода).

## Операции над графами

### Объединение

Объединение графов $G(X,U)=G_1(X_1,U_1)\cup G_2(X_2,U_2)$

- $X = X_1 \cup X_2$
- $\forall x \in X: \Gamma(x) = \Gamma_1(x) \cup \Gamma_2(x)$, где $\Gamma(x), \Gamma_1(x), \Gamma_2(x)$ - множества образов вершины $x$ в графах $G, G_1, G_2$ соответственно.

Для каждой вершины из ранее найденного множества Х множество ее образов в графе $G$ будет определяться как результат объединения образов этой вершины в первом и во втором графе.

### Пересечение

Пересечение графов $G(X,U)=G_1(X_1,U_1)\cap G_2(X_2,U_2)$

- $X = X_1 \cap X_2$
- $\forall x \in X: \Gamma(x) = \Gamma_1(x) \cap \Gamma_2(x)$, где $\Gamma(x), \Gamma_1(x), \Gamma_2(x)$ - множества образов вершины $x$ в графах $G, G_1, G_2$ соответственно.

Замечу, что если при пересечении множеств вершин первого и второго графов получается пустое множество, то эта операция не применима.

### Вычитание

Вычитание графов $G(X,U)=G_1(X_1,U_1) \ G_2(X_2,U_2)$

- $X = X_1 - X_2$
- $\forall x \in X: \Gamma(x) = \Gamma_1(x) \cap X$, где $\Gamma(x), \Gamma_1(x)$ - множества образов вершины $x$ в графах $G, G_1$ соответственно.

### Произведение

Произведение графов $G(V,Z)=G_1(X,U) \cdot G_2(Y,R)$

- $V = X \cdot Y$
- $Z$ - множество ребер и (или) дуг, определяемое по следующему правилу:
  Вершины $(x_i, y_j)$ и $(x_k, y_l)$ будут смежными в графе тогда и только тогда, когда:
  - $x_i = x_k$, $y_j$ и $y_l$ - смежные вершины в графе $G_2$;
  - $y_j = x_l$, $x_i$ и $x_k$ - смежные вершины в графе $G_1$;

# Связность графов

## Связность неографов

### Маршрут

`Маршрут` - это упорядоченная последовательность ребер, в которой каждая пара соседних ребер смежна между собой, т.е имеет одну общую вершину.
`Длина` маршрута определяется количеством ребер в последовательности.

### Цепь

Цепь – это маршрут, в котором все ребра различны.

### Простая цепь

Простая цепь - это цепь, в которой все вершины различны.

Таким образом, основные понятия для определения связности неографа – это маршрут, цепь и простая цепь.

Неограф называется связным, если в нем любую пару вершин можно соединить хотя бы одной простой цепью; в противном случае неограф называется несвязным.

Несвязные части графа называются компонентами связности.

Количество компонент связности является важнейшей характеристикой несвязного графа.

### Разделяющее множество связного графа

Из связного графа можно получить несвязный путем удаления некоторого множества ребер, называемого `разделяющим множеством`.

На практике часто требуется превратить связный граф в несвязный за счет удаления из него минимального количества ребер. Эта задача связана с выделением в связном графе разделяющего множества. Разделяющим множеством называется такое множество ребер, после удаления которых этот граф из связного превращается в несвязный.

Исследование связности неографа связано с решением задачи поиска моста (= перешейка) графа, т.е. того единственного ребра, удаление которого приведет связный граф в несвязный.

Замечу, что не в каждом связном графе найдется мост или перешеек.

## Связность орграфов

### Ориентированный маршрут

`Ориентированный маршрут` – упорядоченная последовательность дуг, в которой каждая дуга имеет вершину истока, совпадающую с вершиной стока предыдущей дуги, и вершину стока, совпадающую с вершиной истока последующей дуги.
`Длина` ориентированного маршрута определяется количеством дуг в последовательности.

### Путь в орграфе

`Путь` в орграфе является аналогом цепи в неографе, т.е. путь – ориентированный маршрут без повтора дуг.

### Полупуть

`Полупуть` – это путь, построенный в орграфе без учета направления дуг.

### Простой путь

`Простой путь` – в орграфе является аналогом простой цепи в неографе, т.е. простой путь – путь без повтора вершин.

### Простой полупуть

`Простой полупуть` - это простой путь, построенный в орграфе без учета направления дуг.

Таким образом, при исследовании связности орграфов следует использовать понятия ориентированного маршрута, пути и простого пути, а также полупути и простого полупути.

### Cвязности орграфа

Орграф называется связным, если в нем любую пару вершин можно соединить хотя бы одним простым полупутем. Поэтому доказательство связности орграфа аналогично доказательству связности неографа, полученного путем замены дуг в исходном орграфе на ребра.

Связный орграф
    - сильным или сильносвязным,
    - слабым или слабосвязным,
    - односторонним или одностороннесвязным.

Множество достижимости вершины $x$ орграфа $R(x)$ состоит из тех вершин $y$, для которых есть простой путь $\mu = (x, \cdots y)$, причем $R(x) \neq \emptyset$.

$R(x)$ - $x$ 的所有可达点

$R(x) = \Gamma^0(x) \cup \Gamma^1(x) \cup \Gamma^2(x) \cup \cdots \cup \Gamma^l(x)$, где $\Gamma^i(x) = \Gamma(\Gamma^{i-1}(x))$, при условии, что $\Gamma^0(x) = {x}$, $l$ - длина пути $\mu$ сопоставимая с количеством вершин орграфа $n$.

| Связность         | графа Условие                                                                                                              |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| Сильная             | $\forall x \in X: R(x) = X$                                                                                                          |
| Слабая               | $\exists x, y \in: x \notin R(y) \land y \notin R(x)$                                                                                |
| Односторонняя | $\left\{\begin{aligned}&\exists x \in X: R(x) \neq X\\ &\nexists x, y \in X: x \notin R(y) \land y \notin R(x) \end{aligned}\right.$ |

## Методика исследования связности орграфов

Методика исследования связности графа:

1. Для заданного графа $G$ построить ряд степенных графов $G^1, G^2, G^3, \cdots$ Построение завершить, если на некотором k-ом шаге выполняется условие: $G^{k-1} = G^k$
2. Если граф $G^k$ - полный, то граф $G$ является связным; в противном случае граф - несвязный.

## Конденсирование орграфов, понятие подграфа

Пусть имеется орграф $G(X,U)$. Новый граф $G^\ast(X^\ast,U^\ast)$ называется `графом-конденсатом` для $G(X,U)$, если в нем сильные подграфы заменены вершинами.

把 $G(X,U)$ 中的强连接的子图换为一个点，得到 $G^\ast(X^\ast,U^\ast)$

Подграфом $G_1(X_1, U_1)$ графа $G(X,U)$ называется граф, порожденный множеством вершин $X_1 \subseteq X$ (если $\lvert X_1 \rvert < \lvert X \rvert$ то подграф $G_1(X_1, U_1)$ называется собственным). Множество $U_1 \subseteq U$ строится по следующему правилу: $\forall (x, y) \in U_1: x,y \in X_1$.

Граф-конденсат $G^\ast(X^\ast,U^\ast)$ сохраняет свойства связности исходного графа $G(X, U)$

$G^\ast$ одностороннесвязный граф => $G$ одностороннесвязный граф.

## Минимальные маршруты в связном графе

- Постановка задачи поиска минимального (`по длине`) маршрута в графе
  Дано: псевдограф $G(X,U)$, $x_c$ и $x_f$ начало и конец маршрута.
  Найти: $\mu = (x_c, \cdots, x_f), l_\mu \to min$.
- Постановка задачи поиска минимального (`по весу`) маршрута в графе
  Дано: взвешенный псевдограф $G(X,U)$, $x_c$ и $x_f$ начало и конец маршрута.
  Найти: $\mu = (x_c, \cdots, x_f), \sum_{\forall u_i \in \mu}w_i \to min$.

## Волновой алгоритм для поиска минимального маршрута в графе

Волновой алгоритм решает задачу поиска минимального по длине маршрута $\mu^\ast=(v,\cdots,p)$ в связном $n,m$-графе $G(X,U)$, где вершины $v$ и $p$ – начало и конец маршрута (задаются в условии задачи).

Идея алгоритма заключается в том, чтобы из источника волны (вершины $v$) распространить числовую волну по графу и строить ее фронты $W_0, W_1, \cdots, W_l$ до тех пор, пока очередной фронт волны $W_l$ не включит в себя конец маршрута (вершину $p$).

Волновой алгоритм является последовательным и решает данную задачу за следующие два этапа:

1. Построение фронтов волны $W_0, W_1, \cdots, W_l$ и разметка вершин графа.
2. Построение минимального маршрута $\mu^\ast$ длиной l по фронтам волны $W_0, W_l, \cdots, W_l$.

**На первом этапе** вначале полагается, что $W_0 = \{v\}$, вершина $v$ получает метку 0 – номера фронта волны. Очередной фронт волны $W_i (i>0)$ строится из образов вершин предыдущего фронта волны $W_{i-1}$ за исключением тех вершин, которые ранее были размечены алгоритмом; все вершины фронта волны $W_i$ получают метку $i$. Фронт волны $W_l$, в который входит вершина конца маршрута – $p$, определяет длину минимального маршрута – $l$.

**На втором этапе** искомый маршрут $\mu^\ast=(v, \cdots, p)$ строится по фронтам волны $W_0, W_1, \cdots, W_l$ следующим образом. Рассмотрим последний фронт волны $W_l$ и положим, что $i=1, \mu_i^\ast=p$. Далее рассмотрим предыдущий фронт волны $W_{i-1}$ и найдем множество вершин $A$, претендующих на включение в маршрут – $A = W_{i-1}\cap\Gamma^{-1}(\mu_i^\ast)$, где $\Gamma^{-1}(\mu_i^\ast)$ – множество прообразов вершины, выбранной в маршрут $\mu^\ast$ на $i$-шаге. Если множество $A$ содержит не одну, а несколько вершин, то выбор конкретной вершины в маршрут $\mu^\ast$ осуществляется по правилу выбора. Например, выбирается первая по счету вершина, или выбирается последняя по счету вершина или вершина выбирается случайным образом. Установим $i=i-1$ и определим выбранную из множества $A$ вершину как $\mu_i^\ast$. Рассмотрим следующий $W_{i-1}$ фронт волны и т.д. до тех пор, пока не будет включена в маршрут $\mu^\ast$ вершина $v$. После завершения этого этапа будет построен минимальный маршрут $\mu^\ast=(v, \cdots, p)$ длиной $l$.

## Метрические характеристики связного графа

Пусть дан связный псевдограф $G(X,U)$, в котором дуги заменены на ребра.

Расстоянием между вершинами $x_i$ и $x_j$ в графе $G(X,U)$ называется величина $d(x_i, x_j)$, определяемая длиной минимального маршрута между ними, такая, что:

1. $d(x_i, x_j) << \infty$
2. $d(x_i, x_j) \ge 0(x_i=x_j \Rightarrow d(x_i, x_j)=0)$
3. $d(x_i, x_j) = d(x_j, x_i)$
4. $d(x_i, x_j) \le d(x_i, x_k) + d(x_k, x_j)$

Пусть $x_i$ - произвольная вершина в графе. Тогда конечная величина $r(x_i)$ будет называться **максимальным удалением (= эксцентриситетом) вершины** $x_i$ в графе $G(X,U)$ и определяться как $r(x_i)=\max_{j=1}^nd(x_i, x_j)$

`Диаметр графа` $D(G)$ определяется как $D(G) = \max_{i,j=1,n}d(x_i, x_j) = \max_{i=1}^n r(x_i)$

`Радиус графа` $R(G)$ определяется как $R(G) = \min_{i=1}^nr(x_i)$

`Центр графа` $X_c \subseteq X$ - множество вершин, удовлетворяющие следующему условию: $\forall x \in X_c: r(x) = R(G)$

`Периферия графа` $X_p \subseteq X$ множество вершин, удовлетворяющие следующему условию: $\forall x \in X_p: r(x) = D(G)$

## Алгоритм Форда-Беллмана

Алгоритм Форда-Беллмана решает задачу поиска `минимального по весу` маршрута $\mu^\ast=(x_v, \cdots, x_p)$ во взвешенном связном псевдографе $G(X, U)$, где $x_v$ и $x_p$ – начало и конец маршрута (задаются в условии задачи). Исходный граф $G(X, U)$ представляется в алгоритме матрицей весов  где $\left\|W\right\|_{n\times n}$ – количество вершин в графе.

Алгоритм Форда-Беллмана основан на принципе оптимальности Беллмана, который для этой задачи означает следующее: минимальный маршрут из вершины $x_v$ до некоторой вершины $x_i-(x_v, \cdots, x_i)$ является частью искомого минимального маршрута $\mu^\ast=(x_v, \cdots, x_p)$ при условии, что маршрут $\mu^\ast$ проходит через данную вершину $x_i$.

Исходный граф $G(X, U)$ представляется в алгоритме матрицей весов $\left\|W\right\|_{n\times n}$ где $n$ – количество вершин в графе. Отметим следующие важные особенности матрицы весов:

- Множество образов вершины $\Gamma(x_i)$ определяют отличные от $\infty$ значения элементов в $i$-ой строке матрицы.
- Множество прообразов вершины $\Gamma^{-1}(x_i)$ определяют отличные от $\infty$ значения элементов в $i$-ом столбце матрицы.

Поставим каждой вершине $x_i \in X$ в соответствие числовую характеристику $\lambda^0(x_i), \lambda^1(x_i), \cdots, \lambda^l(x_i)$, определяемую минимальным весом маршрута – $(x_v, \cdots, x_i)$ с длиной не более $0,1,\cdots,l$. Данные характеристики заносятся в $\lambda$–таблицу размером $n \times l$, где $l \le n$.

Отметим следующие важные особенности $\lambda$–таблицы:

Каждый $i$-й столбец в таблице определяет минимальные веса маршрутов, ведущих из вершины $x_v$ к вершине графа, соответствующей номеру строки с длиной не более $i$.
Каждая $i$-я строка в таблице определяет минимальные веса маршрутов, ведущих из вершины $x_v$ к вершине $x_i$, при условии, что их длина не более $0,1,\cdots, l$ соответственно.

Таким образом, $\lambda$–таблица содержит информацию о всех минимальных по весу маршрутах, ведущих из вершины $x_v$ до любой другой вершины графа, в том числе и до вершины $x_p$.

Поставленная выше задача решается данным алгоритмом за следующие два этапа:

Построение $\lambda$–таблицы для графа, заданного таблицей весов $W$.
Построение по $\lambda$–таблице и матрице весов $W$ искомого минимального по весу маршрута $\mu^\ast=(x_v, \cdots, x_p)$.

Этап №1. Вначале в $\lambda$–таблице заполняется столбец $\lambda^0$. В нем все элементы равны $\infty$ за исключением $\lambda^0(x_v)=0$ (считается, что вершина  достижима сама для себя маршрутом $0$-длины).

Элементы каждого следующего столбца $\lambda$–таблицы заполняются по следующему правилу (процедура релаксации графа):

$$
\lambda^l(x_i) = \min_{\forall x_j \in \Gamma^{-1}(x_i)}(\lambda^{l-1}(x_i), \lambda^{l-1}(x_j)+w_{ji})
$$

То есть для каждой вершины графа проверяем, а не уменьшится ли вес маршрута $(x_v, \cdots, x_i)$, если мы увеличим его длину на одну дугу?

Процедура релаксации графа завершается, если выполняется условие $\lambda^l = \lambda^{l-1}$; в противном случае переходим к заполнению следующего столбца $\lambda$–таблицы.

Этап №2. Строим минимальный по весу маршрут $\mu^\ast=(x_v, \cdots, x_p)$ в обратном порядке, начиная с его конца – вершины $x_p$.

Для этого просматриваем $p$-ую строку в $\lambda$–таблице и находим первый по счету минимальный элемент – $\lambda^t(x_p)$. Номер столбца этого элемента $t$ определяет длину (количество дуг в маршруте), а значение элемента $\lambda^t(x_p)$ – вес искомого маршрута.

Вершина начала каждой очередной дуги, начиная с последней в этом маршруте, определяется по следующему условию:

$$
\lambda^{l-1}(x_j)=\lambda^l(x_i)-w_{ji}
$$

Здесь $x_i$ – найденная ранее вершина начала дуги в $l$-столбце $\lambda$–таблицы (вначале это вершина $x_p$ в $t$-столбце); $x_j$ – вершина из числа прообразов вершины $x_i-\Gamma^{-1}(x_i)$.

Примечание. Если веса всех дуг (ребер) графа $G(X,U)$ определить как «1», то алгоритм Форда-Беллмана найдет минимальный по длине маршрут $\mu^\ast = (x_v, \cdots, x_p)$.

# Циклы в графах

## Циклы в неографах

`Цикл` - замкнутая цепь в неографе, т.е. цепь, в которую добавлено ребро, инцидентное вершинам начала и конца цепи. Длина цикла $l$ определяется количеством ребер в цикле, причем $l > 3$.

`Простой цикл` - замкнутая простая цепь в неографе, т.е. простая цепь, в которую добавлено ребро, инцидентное вершинам начала и конца цепи.

Таким образом, следует различать циклы и простые циклы в неографе: в простых циклах все вершины должны быть различными.

## Циклы в орграфах

`Ориентированный цикл (= контур)` - замкнутый путь в орграфе, т.е. путь, в который добавлена дуга, вершиной истока которой является вершина конца пути, а вершиной ее стока - начало пути.

`Простой контур` - замкнутый простой путь в орграфе, т.е. простой путь, в который добавлена дуга, вершиной истока которой является вершина конца пути, а вершиной ее стока - начало этого пути.

`Полуконтур` - контур, построенный в орграфе без учета направления дуг.

`Простой полуконтур` - простой контур, построенный в орграфе без учета направления дуг.

## Независимые циклы в графе

`Множество циклов графа` $С(G)$ - множество, содержащее все различные простые циклы (простые контуры) этого графа.

`Множество независимых циклов графа` $C_H(G) \subseteq C(G)$ содержит только такие простые циклы (простые контуры) графа, в котором каждый цикл (контур) отличается от других хотя бы одним ребром (дугой). На множестве циклов графа можно построить различные множества независимых циклов этого графа.

## Циклы Эйлера

`Цикл Эйлера` - цикл (контур), проходящий `через все ребра (дуги)` связанного графа.
Граф, содержащий цикл Эйлера, называется `графом Эйлера`. Граф Эйлера можно нарисовать, если «не отрывать карандаш от бумаги и не повторять линий» (теорема Эйлера, 1736 г).

Следствия теоремы для распознавания графов Эйлера:

1. Связный неограф $G(X,U)$ является графом Эйлера, если $\forall x \in X: \rho(x)$ — четное число.
2. Связный орграф С(Х,и) является графом Эйлера, если $\forall x \in X: \rho^+(x) = \rho^-(x)$.

Если граф не является графом Эйлера, но для его построения достаточно добавить одно ребро (одну дугу), то такой граф называется `полуэйлеровым графом`, а цепь (путь), в который добавляется ребро (дуга), называются `цепью Эйлера`.

Следствия теоремы для распознавания полуэйлеровых графов:

3. В полуэйлеровом неографе степени всех вершин - четные за исключением двух вершин (эти вершины и являются началом и концом цепи Эйлера в графе).
4. В полуэйлеровом орграфе полустепени исхода и полустепени захода различаются только у двух вершин $х$ и $у$, причем $\rho^-(x) = \rho^+(x)+1$ и $\rho^+(y)=\rho^-(y)+1$ (вершина $x$ является началом, а вершина $y$ - концом цепи Эйлера в графе).
5. Проверка условия существования цикла Эйлера в заданном графе $G(X,U)$.
6. Если условие выполняется, то решается задача поиска цикла Эйлера. Если условие не выполняется, то закончить решение задачи (данный граф $G(X,U)$ не является графом Эйлера).

Почти нет графовых структур, являющихся графами Эйлера (теорема Рейда, 1962 г.)

## Циклы Гамильтона

`Цикл Гамильтона` - цикл (контур), проходящий `через все вершины` связного графа.
Граф, содержащий хотя бы один цикл Гамильтона, называется `Гамильтоновым графом`.

Если с связном графе $n \ge 3$ выполняется условие $\forall x \in X: \rho(x) \ge n/2$, то данный граф является Гамильтоновым графом (теорема Дирака, 1952 г.)

Если в графе отсутствуют циклы Гамильтона, но для его построения достаточно добавить одно ребро (одну дугу), то такой граф называется `полугамильтоновым графом`, а цепь (путь), в который добавляется ребро (дуга), называется `цепью Гамильтона`.

Почти все связные графы являются графами Гамильтона (теорема Перепелицы, 1969г.)

## ⭐ Алгоритм Робертса и Флореса для поиска циклов Гамильтона в графе

Алгоритм Робертса и Флореса относится к переборным алгоритмам и решает задачу поиска всех возможных вариантов цикла Гамильтона в связном $n,m$-графе $G(X,U)$.

Идея алгоритма заключается в том, что циклы Гамильтона являются замкнутыми цепями Гамильтона. Поэтому в алгоритме осуществляется полный перебор вершин для построения всех возможных вариантов цепей Гамильтона (простых путей, проходящих через все вершины графа без повтора) с проверкой на возможность их замыкания в цикл.

Определим для каждой вершины $x_j(j=1,n)$ множество ее образов – $\Gamma(x_j)$ и построим по ним матрицу образов вершин $\left\|M\right\| _{t\times n}$, где $t$ определяется через мощности множеств $\Gamma(x_j)$ как:

$$
t=\max_{j=1}^n\lvert\Gamma(x_j)\rvert
$$

Заполним данную матрицу $M$ следующим образом:

$$
m_{ij}=\left\{\begin{aligned}&\Gamma_i(x_j) &i\le\lvert\Gamma(x_j)\rvert\\
&0&i>\lvert\Gamma(x_j)\rvert\end{aligned}\right.
$$

0 就是填补空白

Очевидно, что для существования в графе циклов Гамильтона, необходимо выполнение следующего условия:

$$
\forall x_j \in X: \lvert\Gamma(x_j)\rvert > 0
$$

Вершина, с которой в алгоритме начинается перебор, может быть выбрана произвольно, например, с первой по счету вершины $x_1$. Пусть в графе найдена цепь Гамильтона упорядоченная последовательность $S=(x_1,\cdots, x_r)$. Тогда на ее основе можно построить цикл Гамильтона $\mu = (x_1, \cdots, x_r, x_1)$ длиной $l_\mu = n$, если выполняется следующее условие:

$$
x_1 \in \Gamma(x_r)\qquad 3
$$

Условие 3 проверяется путем просмотра элементов $r$-го столбца матрицы $M$.

Перебор всех вариантов циклов Гамильтона в данном алгоритме осуществляется по матрице $M$ следующим образом.

1. Вносим в $S$ одну из вершин графа.
2. Если упорядоченная последовательность $S$ пуста, то перебор закончен, все циклы Гамильтона в графе найдены.
3. Если упорядоченная последовательность $S$ содержит все вершины графа и выполняется условие 3, то строим очередной цикл Гамильтона, удаляем из $S$ последнюю вершину с исключением ее из рассмотрения в следующем просмотре матрицы.
4. Просматриваем столбец последней вершины из последовательности $S$.
5. Если в этом столбце имеется вершина, отличная от других вершин в $S$, то эту вершину добавляем в упорядоченную последовательность $S$ и переходим к п.3.
   Если в столбце нет отличных вершин, то удаляем из $S$ последнюю вершину с исключением ее из рассмотрения в следующем просмотре матрицы и переходим к п.2.

写好每一列后枚举

## Алгоритмы решения задача коммивояжера

**Содержательная постановка задачи о коммивояжере**
Торговец (коммивояжер) должен посетить все города по одному разу из заданного списка и вернуться обратно в тот город, с которого он начал посещение. При этом стоимость его поездки должна быть минимальной.

**Формальная постановка задачи о коммивояжере**
Дано: связный $n,m$ — граф $G(X,U)$ с установленными весами ребер $W=(w_1, \cdots, w_m)$, в котором $w_i$ - стоимость проезда между городами, моделируемыми в графе вершинами концов ребра $u_i$

Пусть $C_H$ — множество всех циклов Гамильтона в графе $G(X,U)$.

Найти: $c^\ast\in C_H$, для которого выполняется следующее условие: $\sum_{\forall u_i \in c^\ast} w_i \to min$.

# Деревья

## Понятие дерева, леса

`Дерево` – связный граф без циклов, а `лес` – несвязный граф, каждая компонента связности которого является деревом.

На $n$ вершинах можно построить $n^{n-2}$ деревьев.

## Свойства деревьев

### Свойство №1.

- Если $n,m$-граф – дерево, то $m=n-1$
- Если $n,m$-граф – лес, то $m-n-k$($k$ – количество компонент связности в графе).
- Пусть $n_1,n_2,\cdots,n_k$ - количество вершин, а $m_1,m_2,\cdots,m_k$ количество ребер в компонентах связности графа. Очевидно, что $n=n_1+n_2+\cdots+n_k, m=m_1+m_2+\cdots+m_k$. Т.к. каждая компонента связности в графе - дерево, то $m_1=n_2-1,m_2=n_2-1,\cdots,m_k=n_k-1$. Общее количество ребер в графе:
  $$
  m=(n_1-1)+(n_2-1)+\cdots+(n_k-1)=(n_1+n_2+\cdots+n_k)-k=n-k
  $$

### Свойство №2.

Если граф – дерево, то каждое его ребро (дуга) – мост, т.е. дерево – минимально связный граф.

### Свойство №3.

Любые две вершины дерева соединены единственной простой цепью (единственным простым полупутем).

### Свойство №4.

Если граф – дерево, то в нем есть хотя бы пара вершин с $\rho(x)=1$ (для неографа), $\rho^+(x)=1$ и $\rho^-(x)=1$ (для орграфа).

### Свойство №5.

Если граф – дерево, то добавление в него нового ребра, инцидентного двум различным вершинам этого дерева приведет к образованию цикла; этот цикл единственный в графе и проходит по вновь добавленному ребру. При этом граф перестает быть деревом.

### Свойство №6.

Если граф – дерево, то добавление в него новой вершины вместе с инцидентным ей ребром с сохранением связности этого графа приводит к построению нового графа, который также является деревом.

### Свойство №7.

Если связный граф не является деревом (в нем есть циклы), то удаляя из циклов ребра, не нарушая связности этого графа, мы получим дерево.

Если задан $n,m$-граф, то дерево будет содержать $(n-1)$ ребро. Поэтому количество ребер для удаления из циклов определяется как $m-n+1$.

## Остовное дерево связного графа, понятие суграфа

`Остовное дерево связного графа` – суграф этого графа со свойствами дерева.

Суграфом графа $G(X,U)$ называется новый граф $G_1(X,U_1)$, в котором $U_1\subseteq U$ порождает этот суграф (если $\lvert U_1 \rvert < \lvert U \rvert$, то cуграф $G_1(X,U_1)$ называется собственным).

## Алгоритмы построения остовного дерева графа

- 深度优先 Метод обхода вершин `вглубь` для построения остовного дерева связного графа
- 广度优先 Метод обхода вершин `вширь` для построения остовного дерева связного графа

## Теорема Прима о минимальном остовном дереве графа

Пусть $G(X,U)$ – связный взвешенный обыкновенный неограф, а $T=\{T_1(X,U_1), T_2(X,U_2), \cdots\}$ – множество его различных остовных деревьев.

`Минимальное остовное дерево (МОД) или дерево Прима` – это остовное дерево графа $T^\ast\in T$ с минимальным суммарным весом его ребер.

Если исходный граф – связный взвешенный псевдограф, то для поиска его МОД
необходимо построить граф $G(X,U)$ следующим образом:

- удалить все петли,
- заменить все дуги на ребра,
- из кратных ребер оставить в графе только одно ребро с минимальным весом.

`Теорема Прима`: Если в дерево $T'(X', U')$, являющееся поддеревом (= подграфом дерева) МОД $T^\ast(X, U^\ast)$ графа $G(X,U)$, добавить новое ребро $(x, y)\in U$ с минимальным весом такое, что $x \in X' \land y \notin X'$, то построенный таким образом граф $T''(X'', U'')$ также будет поддеревом МОД $T^\ast(X,U^\ast)$ графа $G(X,U)$.

**Доказательство**:

1. Пусть имеется поддерево МОД графа $G(X,U) - T'(X',U')$.
2. Определим множество ребер, претендующих на включение в МОД.
3. Построим граф $T''(X'',U'')$ путем добавления в граф $T'(X',U')$ новой
   вершины $x$ вместе с инцидентным ей ребром $$, т.к. данное ребро имеет минимальный вес среди всех ребер, претендующих на включение в МОД.
4. Граф $T''$ – дерево (свойство №5). Граф $T''$ – поддерево $T^\ast$, т.к. приращение суммарного веса его ребер минимально.

## Алгоритмы поиска минимального остовного дерева графа

### ⭐ Алгоритм Прима

Алгоритм Прима дает точное решение задачи построения минимального остовного дерева (МОД) $T^\ast(X,U^\ast)$ связного взвешенного $n,m$-графа $G(X,U)$. Исходный граф задается в виде матрицы весов $\left\|W\right\|_{n\times n}$. Алгоритм строит согласно теореме Прима цепочку из $n$-поддеревьев МОД $T'\to T''\to \cdots \to T^\ast$, где $T'$ – граф, состоящий из одной произвольно выбранной вершины графа $G(X,U)$, например, из вершины $x_1$.

Наращивание МОД $T^\ast(X,U^\ast)$ в алгоритме Прима происходит последовательно. Алгоритм состоит из следующих 2-х этапов:

1. Построение поддерева $T'$.
2. Построение цепочки поддеревьев МОД.

Введем следующие обозначения:

- $g$ - индекс вершины графа $G(X,U)$, выбранной для построения очередного поддерева в цепочке;
- $S$ - суммарная стоимость ребер очередного дерева в цепочке.

На этапе построения поддерева $T'$ выполняются следующие действия:

- $g:=1$
- $S:=0$

На этапе построения **цепочки поддеревьев МОД** в цикле от $i=1$ до $(n-1)$ строится множество ребер МОД – $U^\ast=\{u_1^\ast,u_2^\ast,\cdots,u_{n-1}^\ast\}$. Тело цикла включает в себя следующие действия:

1. 划掉第 $g$ 列并选择第 $g$ 行 В матрице $W$ вычеркиваем $g$-столбец и выделяем $g$-строку.
2. 选择最小的 $w_{ij}$ В матрице $W$ просматриваем все выделенные строки сверху вниз и слева направо и выбираем минимальный элемент $w_{ij}$ (если таких элементов несколько, то выбираем первый по счету элемент).
3. Строим очередное поддерево МОД в цепочке путем добавления новой вершины $x_j$ и ребра $(x_i,x_j)$.
4. $g:=j$
5. $S:=S+w_{ij}$

После завершения цикла МОД $T^\ast(X,U^\ast)$ построено, $S$ – суммарный вес его ребер.

### Алгоритм Краскала

`Алгоритм Краскала` дает точное решение задачи построения минимального остовного дерева (МОД) $T^\ast(X,U^\ast)$ связного взвешенного $n,m$-графа $G(X,U)$. Исходный граф задается в виде таблицы $R_0$, содержащий список ребер исходного графа $U=\{u_1,u_2,\cdots,u_m\}$ и их веса $W=(w_1,w_2,\cdots,w_m)$. Вначале полагается, что каждая вершина графа $G(X,U)$ образует отдельное поддерево МОД. Алгоритм Краскала наращивает дерево $T^\ast(X,U^\ast)$ из своих поддеревьев параллельно-последовательно согласно свойству деревьев №5 (при добавлении нового ребра, инцидентного двум вершинам одного поддерева, образуется цикл).

Алгоритм состоит из следующих 2-х этапов:

1. Этап №1. Формирование таблицы $R$.
2. Этап №2. Построение поддеревьев МОД.

Введем следующие обозначения:

- $X^\ast$ - множество, содержащее подмножества вершин, включенных алгоритмом в поддеревья МОД;
- $m^\ast$ – общее количество ребер, включенных алгоритмом в поддеревья МОД;
- $S$ – суммарная стоимость ребер в поддеревьях МОД.

На **первом этапе** выполняются следующие действия:

1. 将边按权重升序排序 Произвести в таблице $R_0$ сортировку ребер по возрастанию их весов и сформировать таблицу $R$.
2. $m^\ast:=0$
3. $S:=0$
4. $X^\ast=\{\{x_1\},\{x_2\},\cdots,\{x_n\}\}$

На **втором этапе** в цикле от $j=1$ до $m$ до тех пор, пока не выполнится условие $m^\ast=(n-1)$, строить множество $X^\ast$. Тело цикла включает в себя проверку следующего условия о включении $j$-го ребра из таблицы $R$.

如果两端不包括在顶点集合中，则加入该集合 Если оба конца ребра $u_i$ не входят в список вершин одного из поддеревьев МОД, то надо выполнить следующие действия:

1. Построить очередное ребро МОД $u_j$ (выделяем его в списке $R$).
2. $m^\ast:=m^\ast+1$
3. $S:=S+w_{j}$
4. Формируем новое множество $X^\ast$ с учетом ребра $u_j$.

После завершения цикла МОД $T^\ast(X, U^\ast)$ построено, $S$ – суммарный вес его ребер.

## Корневые деревья

- `Корневое дерево` – это связный орграф $G(X,U)$ со следующими свойствами:
  1. $\exists!x_0\in X: \rho^+(x_0)=0$ (вершина $x_0$ – корень дерева);
  2. $\exists x \in X: \rho^-(x) = 0$ (вершины $x$ – листья дерева);
  3. $\forall x \in X \backslash \{x_0\}: \exists!\mu=(x_0,\cdots,x)$.
- `Глубина вершины` $x$ в корневом дереве $v(x)$ определяется длиной пути $\mu=(x_0,\cdots, x)$
- `Высота вершины` $x$ в корневом дереве $h(x)$ определяется длиной **максимального** пути от $x$ до одного из листьев дерева. Высота корневого дерева $H=h(x_0)$.
- `Уровень вершины` $x$ в корневом дереве $y(x) = H - v(x)$

## Двоичные деревья

- `Упорядоченное дерево` – корневое дерево, в котором у каждого отца множество его сыновей упорядочено в некотором отношении порядка. Сыновья в таком дерево изображаются по порядку слева направо.
- `Двоичным (бинарным) деревом` называется такое упорядоченное дерево, в котором:
  - каждый сын отца либо левый, либо правый;
  - каждый отец имеет не более одного левого и не более одного правого сына.
- Двоичное дерево высоты $Н$ называется `полным`, если:
  - вершина с глубиной $v(x)<H$ имеет и левого, и правого сына;
  - вершина с глубиной $v(x)=H$ является листом дерева.
- Полное двоичное дерево высоты $H$ содержит $n=2^{H+1}-1$

# Оптимизация на графах

## Понятие экстремального числа графа

`Экстремальное число графа` $G(X,U)$ - оценка решения некоторой оптимизационной задачи для данного графа (максимума или минимума целевой функции задачи).

Перечень основных экстремальных чисел графа

| № | Оптимизационная задача на графах                                              | Экстремальное число графа         | Обозначение |
| -- | ---------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- | ---------------------- |
| 1  | Поиск максимального числа независимых циклов в графе         | Цикломатическое число                | $\sigma(G)$          |
| 2  | Поиск наибольшего пустого подграфа в графе                            | Число внутренней устойчивости | $\alpha_0(G)$        |
| 3  | Поиск наибольшего полного подграфа в графе                            | Кликовое число                              | $\varphi(G)$         |
| 4  | Минимальная раскраска графа                                                       | Хроматическое число                    | $\chi(G)$            |
| 5  | Минимальное вершинное покрытие графа                                      | Число внешней устойчивости       | $\beta_0(G)$         |
| 6  | Поиск в графе максимального количества независимых ребер | Число паросочетания                    | $\alpha_1(G)$        |
| 7  | Минимальное реберное покрытие графа                                        | Число реберного покрытия           | $\beta_1(G)$         |

## 图的圈数 Цикломатическое число графа

`Цикломатическое число графа` $\sigma(G)$ указывает на количество ребер, которое надо удалить из графа, чтобы получить его остовное дерево (остовный лес).

`图的圈数` $\sigma(G)$ 表示为了获得其生成树（生成森林）而必须从图中删除的边数。

$$
\sigma(G)=m-n+k
$$

Для связного графа: $k = 1$

`Теорема об основном свойстве цикломатического числа графа.`

Цикломатическое число графа $\sigma(G)$ определяет максимальное количество независимых циклов в нем.

**Доказательство теоремы**

Пусть задан обыкновенный $n,m$ — граф $G(X,U)$.

Удалим из него все вершины вместе с инцидентными им ребрами:

- $\forall x \in X:$
  - $\rho(x) = 1$ (для неографа)
  - $\rho^+(х) = 1$ и (или) $\rho^-(х) = 1$ (для орграфа).

Получим новый $n^\ast,m^\ast$—граф $G^\ast(X^\ast.U^\ast)$, причем $\sigma(G)=\sigma(G^\ast)$, т.к. удаленные ребра не входят ни в один цикл $n,m$ — графа $G(X,U)$.

Затем построим в графе $G^\ast(X^\ast.U^\ast)$ его остовное дерево - $n^\ast,(n^\ast-1)$-граф $T^\ast$.

Известно, что $\sigma(T^\ast) = 0$. Поэтому каждое ребро графа $G^\ast$ не вошедшее в $T^\ast$, образует в нем простой цикл (свойство деревьев №4). Причем эти циклы являются независимыми (наличие одного ребра, входящего только в этот цикл).

1. Цикломатическое число любого дерева равно нулю.
2. Цикломатическое число полного $n,m$-графа равно $(n^2 - 3n)/2 + 1$.
3. Цикломатическое число графа Эйлера всегда больше нуля.

## 内部稳定性数 Число внутренней устойчивости

`图的内部稳定性数` $\alpha_0(G)$ 是图中不相邻的最大顶点数。

`Число внутренней устойчивости (= число независимости, = число неплотности) графа` $\alpha_0(G)$ - это максимальное количество вершин в графе, не смежных между собой. $\alpha_0(G)=[1,n]$, причем $\alpha_0(G) = 1$ для полного графа, a $\alpha_0(G) = n$ для пустого графа.

`Внутренне устойчивым множеством (ВУМ)` в графе $G(X,U)$ называется такое подмножество вершин $F \subseteq X$, для которого выполняется следующее свойство внутренней устойчивости - $\forall x \in F: F \cap \Gamma(x) = \emptyset$. Каждое ВУМ порождает в графе $G(X,U)$ пустой подграф.

`Максимальное ВУМ` - это такое ВУМ, которое нельзя увеличить по мощности за счет других вершин графа без нарушения свойства внутренней устойчивости.

`Наибольшее ВУМ` - это максимальное ВУМ с наибольшим количеством вершин графа $G(X,U)$; количество вершин в таком ВУМ и определяет $\alpha_0(G)$.

Оценка верхней границы $\alpha_0(G)$ для связного остовного графа определяется как:

$$
\alpha_0(G) \le \frac12 + \sqrt{(n-\frac12)^2-2m}
$$

2. В связном графе при $n\ge3$ количество вершин, у которых локальная степень $\rho(x)=1$, определяет нижнюю границу числа внутренней устойчивости этого графа.

## Алгоритмы поиска наибольших пустых подграфов в графе

### Алгоритм Магу-Вейсмана

Алгоритм Магу-Вейсмана основан на применении метода Магу для решения задачи поиска наибольших внутренне устойчивых множеств (ВУМ) в ${n,m}$-графе ${G(X,U)}$ без петель.

Метод Магу использует элементы математической логики для решения самых различных оптимизационных задач на графах. Идея метода для данной задачи заключается в следующем. Пусть имеется некоторый граф без петель, построенный на множестве вершин ${ X = \{x_1, x_2, \cdots , x_n \} }$. Пусть ${F}$ – некоторое максимальное ВУМ в этом графе, а $||A||_{n \times n}$ – матрица смежности графа. Определим предикат $x_i$ (здесь и далее курсивом будут обозначаться булевы переменные) условием $x_i = И$ (истина) тогда и только тогда, когда вершина ${x_i \in F}$, а переменную $a_{ij} = И$ тогда и только тогда, когда вершина ${x_j \in \Gamma (x_i)}$, где ${\Gamma (x_i)}$ – множество образов вершины ${x_i}$, причем $i \ne j$. Заметим, что булева переменная $a_{ij}$ совпадает со значением соответствующего элемента матрицы смежности ${a_{ij}}$. По определению внутренней устойчивости следующая формула будет истинной для всех $i, j = 1, \cdots ,n$:

$$
( x_i \And a_{ij} ) \Rightarrow \neg x_j, (1)
$$

где

- $\And$ – знак логического умножения (конъюнкции),
- $\neg$ – знак отрицания,
- $\Rightarrow$ – знак следствия (импликации). Тогда для формулы (1) будет истиной и равносильная ей формула:

$$
\And_{i=1}^n \And_{j=1}^n ( \neg x_i + \neg x_j + \neg a_{ij} ), (2)
$$

где + - знак логического сложения (дизъюнкции). Обратим внимание, что формула (2) получена из формулы (1) с использованием тождества $A \Rightarrow B \equiv \neg A + B$, т.е.:

$$
(x_i \And a_{ij}) \Rightarrow \neg x_j \equiv \neg (x_i \And a_{ij}) + \neg x_j
$$

а затем тождества первого закона де Моргана $\neg (A \And B) \equiv \neg A + \neg B$, т.е:

$$
\neg (x_i \And a_{ij}) \equiv \neg x_i + \neg a_{ij}
$$

Учитывая, что для данного графа значения $a_{ij}$ есть И (истина) или Л (ложь), выражение (2) является формулой логики высказывания только от переменных $x_1, x_2, \cdots , x_n$, т.е. может быть записана как:

$$
\And_{i=1}^n \And_{j=1}^n ( \neg x_i + \neg x_j). (3)
$$

Приведем формулу (3) к сокращенной дизъюнктивной нормальной форме. Тогда каждому дизъюнктивному члену $( \neg x_{i_1} \And \neg x_{i_2} \And \cdots \And \neg x_{i_k})$ в ней соответствует максимальное ВУМ, определяемое как ${X \backslash \{ x_{i_1}, x_{i_2}, \cdots , x_{i_k} \}}$. Таким образом, мы получим все различные максимальные ВУМ графа, а выбрав среди них наибольшее ВУМ, определим порождаемый им наибольший пустой подграф графа и число внутренней устойчивости графа $\alpha_0(G)$. Заметим, что при решении может быть найдено не одно наибольшее ВУМ, а несколько.

Алгоритм Магу-Вейсмана решает данную задачу через поиск дополнений к максимальным ВУМ графа. Пусть ${F}$ – некоторое максимальное ВУМ в этом графе, тогда ${K = X \backslash F}$ будет его дополнением до множества всех вершин графа ${X}$. Определим предикат $x_i$ условием $x_i = И$ тогда и только тогда, когда вершина ${x_i \notin F}$. В такой постановке формула (3) для графа принимает вид:

$$
\And_{i=1}^n \And_{j=1}^n ( x_i + x_j ), (4)
$$

где выражение $(x_i + x_j)$ соответствует дуге ${(x_i,x_j)}$ графа. Напомним, что ребро графа ${(x_i,x_j)}$ является заменой двух встречных дуг – ${(x_i,x_j)}$ и ${(x_j,x_i)}$. Учитывая, что в формуле (4) для каждого ребра будут присутствовать два истинных высказывания $(x_i + x_j)$ и $(x_j + x_i)$, то второе высказывание можно опустить. Алгоритм Магу-Вейсмана решает данную задачу следующим образом:

1. Построение формулы (4) для графа – $\Pi_g$.
2. Приведение формулы $\Pi_g$ к дизъюнктивной нормальной форме.
3. Приведение формулы $\Pi_g$ к сокращенной дизъюнктивной нормальной форме.
4. Определение по формуле $\Pi_g$ всех дополнений до максимальных ВУМ графа.
5. Определение максимальных ВУМ графа.
6. Определение наибольших ВУМ, порождающих в графе наибольшие пустые подграфы, и числа внутренней устойчивости графа $\alpha_0(G)$.

Напомним ряд тождеств, которые потребуются Вам для перехода к сокращенной дизъюнктивной нормальной форме формулы (4).

$$
A \And A \And A_i \And \cdots \And A \equiv A\\
A + A + A_i + \cdots + A \equiv A\\
(A + B) \And (A + C) \equiv A + B \And C\\
A \And (B + C) \equiv A \And B + A \And C
$$

## 团数 Кликовое число графа, понятие графа-дополнения

`图的团数` $\varphi(G)$ 是图中相邻顶点的最大个数。

`Кликовое число (=число зависимости, = число плотности) графа` $\varphi (G)$ - это максимальное количество вершин в графе, смежных между собой.

$\varphi (G) = [1, n]$, причем $\varphi (G) = 1$ для пустого графа, a $\varphi (G) = n$ для полного графа.

`Клика` - это максимальный полный подграф (МПП) в графе, т.е. такой полный подграф (ПП), который нельзя расширить за счет других вершин графа без нарушения его полноты.

`Наибольший полный подграф (НПП)` - это клика графа с наибольшим количеством вершин; количество вершин в НПП и определяет $\varphi (G)$.

`Графом-дополнением скелетного графа` $G(X,U)$ называется новый граф $G_1(X,U_1)$, в котором $U_1=U_n\backslash U$, где $U_n$ - множество ребер полного графа, построенного на вершинах этого графа.

Для решения задачи поиска наибольшего полного подграфа в графе могут использоваться те же методы, что и для решения задачи поиска наибольших пустых подграфов в графе. Для этого необходимо, например, в методе Магу-Вейсмана в качестве исходных данных использовать граф-дополнение. Тогда пустые подграфы в графе-дополнении будут являться полными подграфами исходного графа.

## Алгоритмы поиска наибольших полных подграфов в графе

## 色数 Хроматическое число графа

`Хроматическое число графа` $\chi(G)$ - это минимальное количество цветов для вершинной раскраски графа.

`图的顶点着色`是一种使图中任意两个相邻顶点用不同颜色着色的操作。

`Вершинная раскраска графа` - это операция, в результате выполнения которой любые две смежные вершины в графе раскрашиваются в разные цвета.

$\chi(G) = [1,n]$, причем $\chi(G) = 1$ для пустого графа, a $\chi(G) = n$ для полного графа.

**Примечание**.

1. Для раскраски вершин полного графа требуется п цветов, поэтому $\chi(G)=\rho(x)+1$, где $\rho(x)$ - локальная степень любой вершины полного графа. Тогда для любого связного графа - $\chi(G) \le \rho^\ast(x)+1$, где $\rho^\ast(x) = \max_{i=1}^n\rho(x)$
2. Т.к. вершины МВУМ можно раскрасить одним цветом, то между $\chi(G)$ и $\alpha_0(G)$ существует следующая связь: $\chi(G) \cdot \alpha_0(G) \ge n$. Пусть $\lvert F_i \rvert = n_i$ - количество вершин в МВУМ, $i = \overline{1, \chi(G)}$. Очевидно, что $n_i\le\alpha_0(G)$. Тогда $\chi(G) \cdot \alpha_0(G) \ge n$
3. Любое дерево можно раскрасить двумя цветами, поэтому дерево называют бихроматическим графом.

## Алгоритмы минимальной раскраски графа

### Алгоритм минимальной раскраски графа на основе метода Магу

Данный алгоритм находит все варианты минимальной раскраски вершин ${n,m}$-графе ${G(X,U)}$ без петель. Идея алгоритма состоит в том, что для раскраски вершин любого внутренне устойчивого множества (ВУМ) в графе можно использовать один цвет.

Пусть в графе ${G(X,U)}$ найдено множество максимальных ВУМ ${F = \{ F_1, F_2, \cdots , F_s \} }$, где s – количество максимальных ВУМ в графе. Значение s определяет верхнюю границу хроматического числа графа $\chi (G) $, т.е. $\chi (G) \le s$. Поставим в соответствие каждому множеству ${F_i \in F}$ свой цвет. Тогда задача минимальной раскраски вершин графа может рассматриваться как задача покрытия вершин графа минимальным количеством его максимальных ВУМ, количество максимальных ВУМ при ее решении и определяет хроматическое число графа $\chi (G)$.

Для решения этой задачи построим вначале матрицу ${||C||_{n \times s} }$ следующим образом:

$$
{c_{ij}} = \left \{ 
\begin{aligned}
&1, &\textrm{если вершина } {x_i \in F_j} \\ 
&0, &\textrm{если вершина } {x_i \notin F_j}
\end{aligned} \right. \mkern 60mu (1)
$$

Особенности поиска максимальных ВУМ в графе ${G(X,U)}$ определяют следующее свойство матрицы ${C}$:

$$
{ \forall x_i \in X: \sum_{j=1}^s c_{ij} > 0 }. \mkern 60mu (2)
$$

Определим предикат $F_j$ (здесь и далее курсивом будут обозначаться булевы переменные) условием $F_j = \textrm{И}$ (истина) тогда и только тогда, когда вершина ${x_i}$ раскрашена цветом, соответствующего множества ${F_j}$, а переменную $c_{ij} = \textrm{И}$ тогда и только тогда, когда вершина ${x_i \in F_j}$. Заметим, что булева переменная $c_{ij}$ совпадает со значением соответствующего элемента матрицы ${c_{ij}}$. На основании (2) следующая формула будет истинной для всех $i = 1, \cdots , n$:

$$
F_1 \And c_{i1} + F_2 \And c_{i2} + \cdots + F_s \And c_{is}, \mkern 60mu (3)
$$

где $\And$ – знак логического умножения (конъюнкции), $+$ – знак логического сложения (дизъюнкции). Тогда для минимального покрытия вершин графа его максимальными ВУМ следующая формула будет истинной:

$$
\And_{i=1}^n (F_1 \And c_{i1} + F_2 \And c_{i2} + \cdots + F_s \And c_{is}). \mkern 60mu (4)
$$

Учитывая, что для данного графа значения $c_{ij}$ есть И (истина) или Л (ложь), приведем формулу (4) к сокращенной дизъюнктивной нормальной форме. Тогда каждому дизъюнктивному члену в ней соответствует некоторый вариант покрытия вершин графа его максимальными ВУМ. Дизъюнктивный член с минимальным количеством множителей и определяет решение поставленной задачи покрытия, а количество множителей в нем – хроматическое число графа $\chi (G)$.
Алгоритм решает данную задачу следующим образом:

1. Поиск в ${n,m}$-графе ${G(X,U)}$ без петель множества максимальных ВУМ – ${F = \{ F_1, F_2, \cdots , F_s \}}$.
2. Построение матрицы ${||C||_{n \times s}}$ в соответствии с (1).
3. Построение формулы (4) для графа по матрице ${C – \Pi_G}$.
4. Приведение формулы ${\Pi_G}$ к сокращенной дизъюнктивной нормальной форме.
5. Определение хроматическое число графа $\chi (G)$.
6. Раскраска вершин графа в соответствии с полученным решением задачи минимального покрытия.

Напомним ряд тождеств, которые потребуются Вам для перехода к сокращенной дизъюнктивной нормальной форме формулы (4).

$$
A \And A \And A_i \And \cdots \And A \equiv A \\ A + A + A_i + \cdots + A \equiv A \\ (A + B) \And (A + C) \equiv A + B \And C \\ A \And (B + C) \equiv A \And B + A \And C \\
$$

### Эвристический алгоритм раскраски графа

Данный алгоритм используется для раскраски вершин $n,m$–графа $G(X,U)$ тогда, когда нет жестких требований для поиска точного решения этой задачи. На граф $G(X,U)$ накладываются следующие ограничения.

- Граф $G(X,U)$ должен быть скелетным неографом, в противном случае вначале из него удаляют все петли, дуги заменяют на ребра, а затем кратные ребра заменяют на ребра.
- Граф $G(X,U)$ должен отличаться от полного или пустого графа, в противном случае эта задача является тривиальной.
- Граф $G(X,U)$ должен иметь циклы, в противном случае задача сводится к раскраске дерева или леса в два цвета.
  Известно, что вершины любого пустого подграфа можно раскрасить в один цвет, а вершины любого полного подграфа требуют для каждой вершины отдельный цвет. Идея алгоритма состоит в том, что в первую очередь надо раскрашивать «проблемные» вершины, т.е. вершины с максимальными локальными степенями. Поэтому в этом алгоритме последовательно находятся пустые подграфы, порождаемые такими вершинами, и их раскраска в один цвет продолжается до тех пор, пока все вершины графа не будут раскрашены.

Рассмотрим далее матричную реализацию данного метода. Для этого представим исходный граф $G(X,U)$ в виде матрицы смежности $||M||_{n \times n}$. Очевидно, что тогда локальная степень любой вершины $x_i$ легко определяется по матрице смежности как:

$$
\rho(x_i) = \sum_{j=1}^{n} m_{ij}   (1).
$$

Пусть $p$ – счетчик цветов для раскраски (счетчик пустых подграфов). Для выбора первой вершины $x_t$ в очередной $p$–пустой подграф используем следующий критерий:

$$
\rho(x_t) \rightarrow \max, t=1, \dots, n   (2).
$$

Обозначим $X'$ – множество вершин в очередном $p$–пустом подграфе, а $\Gamma$ – $n$-мерный вектор, определяющий множество образов всех вершин из множества $X'$. Вначале построения очередного $p$–пустого подграфа определим $X' =\{x_t\}$, при этом вектор $\Gamma$ совпадает с $t$-строкой матрицы смежности графа. Очевидно, что у вершин, несмежных с вершинами из множества $X'$, будут нулевые значения соответствующих элементов этого вектора. Выберем из таких вершин для включения в $p$-пустой подграф одну вершину $x_s$ по следующему критерию:

$$
\rho(x_s) \rightarrow \max, s=1, \dots, n   (3).
$$

Если таких вершин несколько, то выберем первую по счету вершину и включим ее в множество $X'$:

$$
X' = X' \cup \{x_s\}   (4).
$$

Скорректируем значения элементов вектора $\Gamma_i$ для всех $i=1,\dots, n$ по следующему правилу:

$$
\Gamma_i = \left. \begin{aligned} 0, & \textrm{если до коррекции } \Gamma_i=0 \textrm{ и } m_{is}=0; \\ -, & \textrm{если до коррекции } \Gamma_i=0 \textrm{ или } m_{is} \textrm{ были вычеркнуты}; \\ 1, & \textrm{в противном случае}. \end{aligned} \right. \mkern 60mu (5)
$$

Данный алгоритм решает задачу следующим образом.

- Построим матрицу смежности графа и вычеркнем в ней элементы на главной диагонали.
- $р=1$.
- Посчитаем по формуле (1) локальные степени вершин.
- Выбор первой вершины в $p$-пустой подграф. Выбираем вершину $x_t$ согласно критерию (2) (если таких вершин несколько, то выбираем первую по счету вершину); определим множество $X' =\{x_t\}$ и вектор $\Gamma$ как $t$-строку матрицы смежности.
- Если вектор $\Gamma$ не содержит нулевых элементов, то перейти к п. 7.
- Выбор очередной вершины в p-пустой подграф. Выбираем для нулевых элементов вектора $\Gamma$ вершину $x_s$ согласно критерию (3) (если таких вершин несколько, то выбираем первую по счету вершину); определим множество $X'$ согласно (4) и скорректируем элементы вектора $\Gamma$ по правилу (5). Перейдем к п.5.
- Раскрасим вершины из множества X' в цвет с кодом p и удалим их из графа вместе с инцидентными им ребрами, т.е. вычеркнем из матрицы смежности соответствующие строки и столбцы.
- Если не все вершины раскрашены, то увеличим счетчик цветов $p:=p+1$ и перейдем к п. 3.
- Задача решена. Для раскраски вершин потребовалось $p$ цветов.

## 外部稳定性数 Число внешней устойчивости графа

`图的外部稳定性数` $\beta_0(G)$ 是其图像是该图的所有其他顶点的最小顶点数。

`Число внешней устойчивости (= число вершинного покрытия, = число опоры) графа` $\beta_0(G)$ - это минимальное количество вершин, образами которых являются все остальные вершины этого графа.

外部稳定数是最少的连接图的所有点的点集的数量

**Примечание.**

1. Графы, содержащие изолированные вершины, не имеют вершинного покрытия.
2. Если в графе $G(X.U), \exists x \in X: \rho(x) = n-1$, то $\beta_0(G)=1$.

`Внешне устойчивым множеством (=опорой) графа` называется такое множество вершин $R \subseteq X$ со следующим свойством внешней устойчивости $R \cup \Gamma(R) = X$, где $\Gamma(R) = \cup_{\forall x \in R)}\Gamma(x)$

`Минимальная опора` - это такая опора в графе, которую нельзя уменьшить по мощности без нарушения свойства внешней устойчивости.

`Наименьшая опора` - это минимальная опора в графе с наименьшим количеством вершин; количество вершин в наименьшей опоре и определяет $\beta_0(G)$.

Наименьшее число клик для вершинного покрытия графа определяет число кликового покрытия	$\beta_\varphi(G)$, причем $\beta_\varphi(G) \ge \beta_0(G)$.

## 独立边集数 Число паросочетания графа

`Число паросочетания (= число независимости ребер) графа` $\alpha_1(G)$ - это максимальное количество несмежных между собой ребер графа. Число паросочетания орграфа $\alpha_1(G)$ определяется в графе, в котором дуги заменены на ребра. В связном графе $\alpha_1(G) \le [\frac n2]$

`Паросочетание` - это любое подмножество ребер графа, не смежных между собой.

`Максимальное паросочетание` - это паросочетание в графе, которое нельзя расширить за счет других ребер графа без нарушения свойства независимости ребер в данном паросочетании.

`Наибольшее паросочетание` - это максимальное паросочетание с наибольшим количеством ребер; количество ребер в наибольшем паросочетании и определяет $\alpha_1(G)$.

## 最少边组成图数 Число реберного покрытия графа

`Число реберного покрытия графа` $\beta_1(G)$ - это минимальное количество ребер для покрытия всех вершин графа. Графы с изолированными вершинами не имеют реберного покрытия. В связном $n,m$ — графе $\left[\frac n2\right]\le \beta_1(G) \le m$

`Реберное покрытие графа` - это любое подмножество ребер графа, которое покрывает все вершины этого графа (каждая вершина графа инцидентна хотя бы одному ребру из этого подмножества).

`Минимальное реберное покрытие графа` - это такое реберное покрытие графа, которое нельзя уменьшить по количеству ребер без нарушения свойства вершинного покрытия ребрами данного графа.

`Наименьшее реберное покрытие графа` - это минимальное реберное покрытие графа с наименьшим количеством ребер; количество ребер в таком покрытии и определяет $\beta_1(G)$.

# Двудольные графы

## 二分图 Понятие двудольного графа (графа Кёнига)

`Двудольным графом (= графом Кёнига)` называется граф $K(X,U)$, у которого множество
вершин $X$ состоит из двух долей (подмножеств) - $X_1$ и $X_2$ таких, что:

$$
X=X_1 \cup X_2, X_1 \cap X_2 = \emptyset
$$

а множество $U$ состоит только из таких ребер и (или) дуг, для которых выполняется
следующее условие:

$$
\forall(x,y) \in U: x \in X_1, y \in X_2
$$

**Примечание:**

1. Граф Кёнига можно раскрасить в два цвета, т.к. вершины в долях не смежны между собой. Поэтому граф Кёнига называют еще и бихроматическим графом.
2. Число внутренней устойчивости графа Кёнига $\alpha_0(K) = \max(\lvert X_1 \rvert, \lvert X_2 \rvert)$

## Теорема Кёнига (критерий двудольности графа)

`Теорема Кёнига (критерий двудольности графа).`

Для двудольности графа необходимо и достаточно, чтобы этот граф не содержал простых циклов нечётной длины.

**Доказательство необходимости.**

Пусть задан двудольный граф $K(X,U)$, содержащий множество циклов $C$.

$\forall c \in C: l_c=4,6,8,\cdots$, т.к. по определению двудольного графа все простые циклы в нем строятся из ребер, концы которых находятся в разных долях этого графа.

**Доказательство достаточности.**

Пусть задан граф $G(X,U)$, содержащий множество циклов $C$.

Разметим вершины этого графа с помощью  метода обхода вершин вширь следующим образом. Произвольно выберем первую вершину в графе», например, $x_1$ и присвоим ей числовую метку «1». Далее присвоим метку «2» образам этой вершины, а метку «3» - образам вершин, получивших метку «2» и т.д. до тех пор, пока все вершины графа не будут размечены.

При разметке вершин цикла $c \in C$ с чётной длиной каждая вершина получит метки из ряда «1,3…» или «2,4,…». Если в графе все циклы только чётной длины, то все вершины делятся на две доли $X_1$ и $X_2$ с метками «1,3…» или «2,4,…», причем ребра, входящие в эти циклы, будут инцидентны вершинам из разных долей.

При разметке вершин цикла $c \in C$ с нечётной длиной каждая вершина получит чётные и нечётные метки. Такие вершины нельзя разбить на две доли двудольного графа $X_1$ и $X_2$, т.к. $X_1 \cap X_2 \neq \emptyset$

**Примечание**: Любое дерево (лес) является графом Кёнига.

## Задача линейного назначения, понятие совершенного паросочетания графа

`Содержательная постановка задачи линейного назначения`

Имеется $n$ вакантных рабочих мест, на которые претендуют $n$ рабочих. Известна стоимость назначения каждого рабочего на каждое вакантное рабочее место. Необходимо так распределить рабочих по рабочим местам, чтобы суммарная стоимость такого назначения была минимальной.

`Формальная постановка задачи линейного назначения`

**Дано**: взвешенный полный двудольный граф $K(X,U)$, в котором множество вершин $X$ состоит из двух долей - $R$ и $Y$($R$ моделирует $n$ рабочих, а $Y$ – $n$ рабочих мест). Граф
представлен матрицей весов $\left\|W\right\|_{n\times n}$, в которой $w_{ij}$ – стоимость назначения $i$-го рабочего на $j$-место.

**Найти**: Совершенное паросочетание $U^\ast \subset U$ в графе $K(X,U)$.

`Совершенное паросочетание` – это наибольшее паросочетание графа с минимальным
суммарным весом его ребер.

## ⭐ Венгерский алгоритм решения задачи линейного назначения

### Венгерский алгоритм

Алгоритм получил такое название потому, что в его основе лежат результаты исследований венгерских математиков Кёнига и Эгервари. Венгерский алгоритм используется для решения оптимизационной задачи поиска во взвешенном полном двудольном графе $K(X,Y;U)$ совершенного паросочетания, т.е. наибольшего паросочетания с минимальным суммарным весом его ребер, в котором вес каждого ребра $(x,y) \in U$ определяется стоимостью (ценой) назначения рабочего $x \in X$ на место $y \in Y$ (задача линейного назначения). Граф $K(X,Y;U)$ в алгоритме представляется в виде матрицы весов $||C||_{n \times n}$, где $n$ – количество рабочих и количество вакантных мест для них.

Введем понятие потенциала назначения рабочего на вакантное место $y_i + y_j \le c_{ij}$, где $y_i$ – потенциал рабочего, $y_j$ – потенциал рабочего места. Очевидно, что назначение будет оптимальным, если $y_i + y_j = c_{ij}$ для всех $i,j=1,\dots, n$. Алгоритм базируется на следующих двух положениях:

1. Если из всех элементов некой строки или столбца матрицы $C$ вычесть или прибавить одно и то же число, то общая стоимость уменьшится или увеличится на это число, а оптимальное решение при этом не изменится.
2. Если есть решение нулевой стоимости, то оно оптимально.

Алгоритм решает задачу за три этапа:

1. Этап №1. Построить по графу $K(X,Y;U)$ новый граф $K^\ast(X, Y; U^\ast)$, в котором есть ребра с нулевой стоимостью (выделяются в соответствии с положением №1).
2. Этап №2. Построить в графе $K^\ast(X, Y; U^\ast)$ паросочетание с нулевой стоимостью. Если данное паросочетание содержит меньше, чем из n ребер, то перейти к следующему этапу алгоритма; в противном случае задача решена.
3. Этап № 3 (итерационный) . Поиск в графе $K^\ast(X, Y; U^\ast)$ простых цепей, проходящих через все вершины графа без повтора вершин. Если такие цепи найдены (их может быть в графе несколько!), то построить на их основе совершенное паросочетание $U_c \subset U^\ast$, которое дает оптимальное решение задачи назначения согласно положению №2. Оценка полученного решения определяется как:

$$
O(K) = \sum_{\forall u \in U_c}c(u). \mkern 60mu (1)
$$

Рассмотрим далее матричную схему реализацию данного алгоритма для поиска совершенного паросочетания c максимальным суммарным весом его ребер.

**На этапе №1** выполняются следующие действия, целью которых является матричное представление графа $K^\ast(X, Y; U^\ast)$.

1. Для каждого $j$-го столбца матрицы C определим минимальное значение его элементов – $min_j$. Построим вспомогательную матрицу $C'$ следующим образом: $c'_{ij} = c_{ij} - min_j$.
2. Для каждой $i$-ой строки матрицы $C'$ минимальное значение ее элементов – $min_i$. Построим искомую матрицу $C_0$ следующим образом: $c_{0_{ij}} = c'_{ij} – min_i$.

Таким образом полученная матрица $C_0$ определяет ребра нулевой стоимости для графа $K^\ast(X, Y; U^\ast)$, из которых стоится соверешенное паросочетание.

**На этапе №2** поочередно просматриваем столбцы матрицы $C_0$ и отмечаем символом "$\ast$" в них нулевые элементы так, чтобы в строках этих элементов не было других $0^\ast$. В результате получим некоторое паросочетание в графе $K(X, Y; U)$, которое имеет нулевую стоимость в графе $K^\ast(X, Y; U^\ast)$. Если количество ребер в найденном паросочетании меньше $n$, то переходим к этапу №3, в противном случае задача решена.

**На этапе №3** выполняются следующие действия, целью которых является построение простых цепей, проходящих через все вершины графа $K^\ast(X, Y; U^\ast)$, и определение по ним совершенного паросочетания в исходном графе $K(X, Y; U)$.

1. Столбцы матрицы $C_0$, содержащие $0^\ast$, выделим знаком "$+$". Если количество выделенных столбцов равно $n$, то решение получено. При этом элементы матрицы $0^\ast$ определяют искомое совершенное паросочетание - $Uc$, а оценка эффективности полученного решения задачи линейного назначения $O(K)$ определяется по формуле (1).
2. Проверяем, есть ли среди невыделенных элементов матрицы хотя бы один 0?
3. Если таких элементов нет, то введем в граф $K^\ast(X, Y; U^\ast)$ новое ребро. Для этого среди невыделенных элементов матрицы находим элемент с минимальным значением и заменяем его на $0$. Переходим к п.2.
4. Проверяем, содержит ли строка с невыделенным нулем также и $0^\ast$?
5. Если такой элемент есть, то невыделенный ноль отмечаем как 0', включаем оба эти элемента $0'$ и $0^\ast$ в цепочку $0'$, $0^\ast,\dots, 0'$; строку с $0'$ выделим знаком "$+$"; снимаем знак "$+$" со столбца, в котором находится $0^\ast$; переходим к п. 2.
6. Если такого элемента нет, то цепочка $0', 0^\ast,\dots, 0'$ построена.
7. Проверяем, содержит ли цепочка $0', 0^\ast,\dots, 0'$ более двух элементов?
8. Если да, то заменяем в построенной цепочке все $0'$ на $0^\ast$, а все $0^\ast$ на $0$. Снимаем все метки со строк и столбцов матрицы. Переходим к п.1.
9. Если нет, то $0'$ заменяем на $0$ и не рассматриваем его на следующем шаге, снимаем знак "$+$" с его строки, а столбец с $0^\ast$ из цепочки отмечаем знаком "$+$". Переходим к п.2.

Примечание. Каждая вновь построенная цепочка $0', 0^\ast,\dots, 0'$ имеет нечетную длину, что приводит к увеличению паросочетания на одно ребро. Поэтому поиск совершенного паросочетания в венгерском алгоритме осуществляется не более, чем за $(n-2)$ итераций.

## Кёнигово представление гиперграфа, понятие гиперграфа

$$
X=\{x_1, x_2, \cdots, x_n\}, X \neq \emptyset
$$

Гиперграф $H(X, R)$ – это:

- графовая модель, задающая $N$-арное отношение на множестве
  $$
  X \cup X \ast X \cup X \ast X \ast X \cup \cdots \cup X \ast X \ast \cup \ast X
  $$
- отношение инцидентности на множествах $X$ и $R$, где $X$ – множество вершин, а $R$ – множество его гипердуг (гиперрёбер), причём $\forall r \in R: r \subset X$.

**Примечание.**

1. Количество вершин $n$ и количество гиперрёбер $m$ определяют **порядок гиперграфа** (аналог размерности бинарного графа).
2. Равные множества в $R$ называются **кратными гиперрёбрами**.
3. Количество вершин, инцидентных гиперребру $r \in R$, определяет **степень этого гиперребра** – $\rho(r)$, причем $\rho(r) \ge 1$.
4. **Смежность** в гиперграфах. Два гиперграфа $r'$ и $r''$ называются смежными, если
   выполняется условие $r' \cap r'' \neq \emptyset$.
5. **Однородность** гиперграфов. Если в гиперграфе $H(X, R)$ выполняется условие $\forall r \in R: \rho(r) = h$, то такой гиперграф называется $h$-однородным или $h$-униформным.
6. Бинарный граф является частным случаем гиперграфа, причем однородным с $h = 2$.

`Кёнигово представление гиперграфа` $H(X, R)$ – это двудольный граф $K(H) = G(X', U)$, где $X' = X \cup R$ – множество вершин, а $U$ – множество рёбер, моделирующих инцидентность вершин и гиперрёбер в гиперграфе $H(X, R)$.

**Примечание.**

1. В Кёниговом представлении гиперграфа $H(X, R)$ количество вершин – $n + m$, а количество бинарных рёбер - $\sum_{\forall r \in R}\rho(r)$.
2. Кёнигово представление гиперграфа $H(X, R)$ адекватно отображает свойства этой модели
   (инцидентность вершин и гиперрёбер).
3. Кёнигово представление гиперграфа $H(X, R)$ позволяет использовать для гиперграфов все
   известные методы и алгоритмы, разработанные для бинарных графов.
4. Гиперграф можно представить в виде ненулевой подматрицы смежности

   $$
   \left\|M\right\|_{n\times n}$ или ненулевой подматрицы связности
   $$

   \left\|A\right\|_{n\times n}$ его Кёнигова представления.

`Двойственность гиперграфов`

Пусть имеется $n, m$-гиперграф $H(X, R)$ без изолированных вершин. Тогда новый $m,n$-гиперграф $H^\ast(X^\ast, R^\ast)$ называется двойственным к гиперграфу $H(X, R)$, если в нем $X^\ast = R$, $R^\ast$ - множество гиперрёбер, каждое гиперребро r^\ast_i моделирует инцидентность гиперрёбер в исходном гиперграфе $H(X, R)$ вершине $x_i$.

**Примечание.**

1. Если гиперграф $H(X, R)$ не имеет изолированных вершин, то $(H^\ast)^\ast = H$.
2. Гиперграф $H(X, R)$ без изолированных вершин и двойственный к нему гиперграф $H^\ast(X^\ast, R^\ast)$ имеют общее Кёнигово представление, т.е. $К(Н) = K(H^\ast)$.

`Цепью в гиперграфе` $H(X, R)$ с длиной $l > 0$ называется такая упорядоченная последовательность $\mu = (x_1,r_1,\cdots,r_l,x_{l+1})$, в которой:

1. Все вершины $x_1,\cdots,x_{l+1}$ различны между собой,
2. Все гиперрёбра $r_1,\cdots,r_l$ различны между собой,
3. Каждое гиперребро $r_i$ инцидентно вершинам $x_i$ и $x_{i+1}$.

`Цикл в гиперграфе` $H(X, R)$ – это замкнутая цепь, т.е. цепь, в которой $x_1=x_{l+1}$.

**Примечание.**

1. Понятие цепи и цикла в гиперграфе соответствует понятию простой цепи и
   простого цикла в неографе.
2. Поиск цепей и циклов в гиперграфе сводится к поиску простых цепей и простых
   циклов в его Кёниговом представлении.
3. Длина цепи (цикла) в гиперграфе определяются количеством гиперрёбер в
   последовательности.
4. Минимальная длина цикла в гиперграфе – 2 (как минимум два гиперребра).
5. Понятие связности гиперграфа аналогично понятию связности графа: в связном
   гиперграфе любая пара вершин может быть соединена хотя бы одной цепью.
6. Количество компонент связности гиперграфа совпадает с количеством компонент
   связности его Кёнигова представления, т.е. $k(H) = k(K)$.

`Цикломатический ранг` гиперграфа $H(X, R) - \sigma(H)$ определяется цикломатическим числом
его Кёнигова представления $K(H)$.

Известно, что для любого бинарного графа $\sigma(G) = m(G) – n(G) + k(G)$.

Для графа $К(H): n(K) = n + m, m(K) = \sum_{\forall r \in R}\rho(r), k(H) = k(K)$.

Тогда $\sigma(H) = \sigma(K) = \sum_{\forall r \in R}\rho(r)-(n+m)+k(K)$.

**Примечание.**

1. Цикломатический ранг гиперграфа указывает на то, сколько рёбер надо удалить
   в его Кёниговом представлении, чтобы превратить его в остовное дерево
   (остовный лес).
2. Удаление каждого бинарного ребра $(x, r)$ в Кёниговом представлении
   гиперграфа приводит к удалению вершины $x$ из гиперребра $r$.

`Подгиперграфом`, порожденным в гиперграфе $H(X, R)$ непустым множеством $X' \subset X$, называется новый гиперграф $H'(X', R')$, в котором $R'=\{r': r' = r \cap X'; r' \neq \emptyset\}$.

## Моделирование сложных объектов

# Изоморфизм и гомеоморфизм

## Понятие изоморфизма, необходимые условия изоморфизма двух графов

Два графа $G_1(X,U)$ и $G_2(Y,V)$ называются изоморфными (тождественными по структуре), если задано такое биективное (взаимно однозначное) отображение $\varphi X \to Y$, при котором любые две вершины $x_i$ и $x_j$ смежны в графе $G_1$ тогда и только тогда, когда смежны их образы $\varphi(x_i)$ и $\varphi(x_j)$ в графе $G_2$.

Обозначение изомофизма: $G_1(X,U) \cong G_2(Y,V)$

Необходимые условия изоморфизма двух графов $G_1(X,U)$ и $G_2(Y,V)$:

1. $\lvert X \rvert = \lvert Y \rvert$
2. $\lvert U \rvert = \lvert V \rvert$
3. Равное количество вершин, имеющих в неографах одинаковые локальные степени, а в орграфах – одинаковые полустепени исходов, полустепени заходов.

Замечание:

1. Изоморфные графы отличаются только обозначением вершин.
2. Изоморфизм – это отношение эквивалентности на множестве графов.

## Понятие гомеоморфизма

Два графа $G_1(X,U)$ и $G_2(Y,V)$ называются `гомеоморфными (подобными по структуре)`, если из графа $G_1(X,U)$ можно получить путем применения операций стягивания его ребер и (или) расщепления его вершин новый граф $G^\ast(X^\ast,U^\ast)$ такой, что $G^\ast(X^\ast,U^\ast) \cong G_2(Y,V)$.

Обозначение гомеоморфизма: $G_1(X,U) \sim G_2(Y,V)$.

`Стягивание ребра` $(x,y)$ – это операция замены в графе бинарного ребра $(x,y)$ новой вершиной $z$; причем $\Gamma(z) = \Gamma(x) \cup \Gamma(y)$.

`Расщепление вершины` $z$ – это операция замены этой вершины в графе на две вершины $x$ и $y$ вместе с инцидентным им ребром, причем $\Gamma(z) = \Gamma(x) \cup \Gamma(y)$ и $\Gamma(x) \cap \Gamma(y) = \emptyset$.

С этой операцией связана проблема деления множества образов вершины $z - \Gamma(z)$ на два
подмножества $\Gamma(x)$ и $\Gamma(y)$.

## ⭐ Алгоритмы установления изоморфизма двух графов

### Алгоритм на основе локальных характеристик отношения между вершинами

Данный алгоритм устанавливает изоморфизм двух $n,m$-графов $G(X,U)$ и $H(Y,E)$, для которых предварительно выполнены все необходимые условия изоморфизма. При этом графы могут содержать кратные дуги, ребра и петли, т.е. данный алгоритм пригоден для псевдографов.

В основе данного алгоритма – метод свободной и зависимой интеграции структурных различий (метод ISD), который позволяет дифференцировать вершины графа с учетом особенности их расположения относительно всех других вершин графа. Авторы этого метода ставят под сомнение постулат о NP-полноте задачи установления изоморфизма двух графов, что вызывает большой интерес к этому методу.

Метод построен на выявлении тех свойств (атрибутов) графа, которые позволят определить различия между его вершинами. Атрибуты бывают назначаемые и вычисляемые. Назначаемые атрибуты отражают заданные свойства моделируемого объекта, например, ребра, дуги и петли вершин графа. Каждому такому атрибуту назначается свой код (символ или число), на основе которых строится атрибутивная матрица связности графа $S^0$. В результате каждая вершина графа получает свое кодовое значение интегрального описателя – исходный набор локальных характеристики (ЛХ) отношения между вершинами графа. Вычисляемые атрибуты (порядковый номер уникального набора ЛХ вершин) определяются итерационно по матрице $S^0$ и представляют собой вектора интегральных описателей ЛХ вершин. На первой итерации определяется вектор $P^0$. Этот вектор и служит для исходной дифференциации вершин.

Если на первой итерации не было обнаружено различий вершин (все наборы ЛХ вершин одинаковы), то данный алгоритм не может быть использован для решения поставленной задачи. Такой случай относится к регулярным графам. Но и в том случае, когда частично произошла исходная дифференциация вершин графа (имеются неодинаковые наборы ЛХ вершин), не всегда удается добиться полной дифференциации вершин. Такой случай относится к графам, имеющим устойчивые однородные группы (подмножество вершин с одинаковыми наборами ЛХ, которые в процессе решения задачи не отличаются друг от друга). Обсуждение особенностей применения данного метода для регулярных графов и графов с устойчивыми однородными группами выходит за рамки данного алгоритма.

Для дифференциации вершин на второй итерации находится композиция вектора-строки матрицы $S^0$ и вектора $P^0$, в результате которой будет получена новая матрица $S^1$ и определен новый вектор $P^1$. Если при этом не произошла полная дифференциация вершин графа, то находится композиция вектора-строки матрицы $S^0$ и вектора $P^1$ и т.д. до тех пор, пока не будут полностью установлены структурные различия в графе.

Данный алгоритм использует числовые коды атрибутов и состоит в построении ряда обобщенных матриц связности $S^0(G), S^1(G), \cdots , S^f(G)$ и $S^0(H), S^1(H), \cdots , S^f(H)$, позволяющих дифференцировать вершины в графах $G(X,U)$ и $H(Y,E)$. Все матрицы имеют размерность $n \times n$, где $n$ – количество вершин в каждом графе.

Введем следующие обозначения:

- $E_{ij}$ - число дуг, исходящих из $i$-й вершины и входящих в $j$-ю вершину, причем $i \ne j$;
- $O_{ij}$ - число ребер, инцидентных $i$-й и $j$-й вершинам;
- $Z_{ij}$ - число петель при $i$-й вершине, причем $i = j$.

Алгоритм является итерационным, каждая итерация содержит следующие два этапа решения:

1. Построение очередной пары матриц из ряда.
2. Дифференциация вершин графов по матрицам.

Матрица $S^0$ содержит локальные характеристики (ЛХ) отношения между вершинами графа, которые определяются следующим образом:

$$
s^0_{ij} = \left\{ \begin{aligned} &E_{ij} \cdot 10^q + O_{ij} &\ \textrm{при } i \ne j, \\ &Z_{ij} &\ \textrm{при } i = j, \end{aligned} \right. \mkern 60mu (1)
$$

где значение $q$ определяется числом десятичных разрядов в мультичисле графа (максимальное количество кратных ребер (дуг) графа). Для графов с мультичислом, не превышающим 10, значение $q = 1$. В этом случае атрибутом дуги в матрице $S^0$ будет второй разряд, а атрибутом ребра (петли) – первый разряд в числе ЛХ.

Для дифференциации вершин определим вначале различные наборы ЛХ вершин в матрицах $S^0$ и пронумеруем их как $1,2, \cdots$ в том порядке, в котором они встречаются при последовательном просмотре строк матриц. Порядок перечисления ЛХ в наборе не учитывается, например, $(10,10,1), (10,1,10), (1,10,10)$ – это один и тот же набор ЛХ. Затем поставим в соответствие строкам матрицы $S^0$ вектор $P^0 = (p^0_1, p^0_2, \cdots , p^0_n)$, каждый элемент которого $p^0_i$ является номером (кодом) ЛХ отношения $i$-й вершины с другими вершинами этого графа. При этом строки матрицы, имеющие одинаковые наборы ЛХ, получают одинаковые коды. Если при кодировании были получены одинаковые коды для двух и более вершин графа, то дифференциации вершин пока не произошло и следует перейти к следующей итерации.

Матрица $S^k (k>0)$ содержит локальные характеристики (ЛХ) отношения между вершинами графа, которые определяются для ненулевых элементов матрицы $S^0$ как композиция вектора-строки матрицы $S^0$ и вектора $P ^{k-1}$ следующим образом:

$$
s^k_{ij} = s^0_{ij} \cdot 10^{2w} + p^{k-1}_i \cdot 10^w + p^{k-1}_j , \mkern 60mu (2)
$$

где значение $w$ определяется числом десятичных разрядов в величине $n$. Например, для графов с $n<10$ значение $w = 1$ и последние два разряда ЛХ отводятся для кодов ЛХ вершин данного элемента структуры (ребра, дуги или петли).

После построения матрицы $S^k$ аналогично находится соответствующий ей вектор $P^k = (p^k_1, p^k_2, \cdots , p^k_n)$. Т.е. просматриваются строки матрицы $S^k$, определяются в них различные наборы ЛХ, которые опять нумеруются по порядку как $1,2, \cdots$.

Процесс дифференциации вершин завершается тогда, когда на некоторой f-итерации каждая вершина данного графа получит свой код, отличный от других. Если при кодировании был использован хотя бы один код, значение которого превышает $n$, то делается вывод о том, что данные графы $G(X,U)$ и $H(Y,E)$ не являются изоморфными. В противном случае графы $G(X,U)$ и $H(Y,E)$ являются изоморфными. При этом полученные коды указывают на взаимно однозначное соответствие вершин этих графов $\phi : X \to Y$.

# Плоские и планарные графы

## Понятие плоского и планарного графа

`Плоским графом` называется граф, который изображен на плоскости без пересечения и
самопересечения ребер (дуг).

Если граф изображен на плоскости с пересечением и (или) самопересечением ребер (дуг), но существует плоский изоморфный ему граф, то такой граф называется `планарным`; в противном случае граф называется `непланарным`.

Из определения планарного графа следуют следующие утверждения:

1. Всякий подграф планарного графа планарен.
2. Граф планарен тогда и только тогда, когда каждая компонента его связности планарна.

## Свойства плоских укладок графа

`Задача плоской укладки планарного графа.`

Пусть имеется пространство $L$ – плоскость для укладки графа $G(X,U)$. Необходимо найти такое отображение вершин и ребер (дуг) графа $G(X,U)$ в точки и кривые Жордана пространства $L$, чтобы:

- различным вершинам графа соответствовали различные точки;
- кривые Жордана, соответствующие различным ребрам (дугам) графа, пересекались между собой только в точках, соответствующих инцидентным этим ребрам (дугам) вершинам графа.

`Гранью плоского графа` называется максимальное по включению множество точек плоскости, в котором каждая пара точек может быть соединена кривой Жордана, не пересекающей ребра (дуги) графа. `Границей грани` будем считать множество вершин и ребер (дуг) графа, принадлежащих одной грани.

Утверждение 1.

В плоском графе имеется одна внешняя грань, остальные грани – внутренние.

Утверждение 2.

Плоская укладка дерева приводит к построению плоского графа с одной гранью; причем эта грань – внешняя.

Утверждение 3.

Понятие грани распространяется на псевдографы.

Утверждение 4.

Стереографическая проекция плоского графа позволяет превратить любую внутреннюю грань во внешнюю.

1. Всякий планарный граф допускает плоскую укладку, в которой любая выбранная вершина будет принадлежать внешней грани (на основании утверждения №4).
2. Склейка двух плоских графов по общей вершине (по общему ребру) приводит к образованию нового плоского графа.
3. Две различные вершины графа, находящиеся на границе некоторой грани плоского графа, можно соединить кривой Жордана, которая разобьет эту грань на две грани.
4. Каждая точка плоскости $L$, в которой уложен некоторый граф, входит:
   - только в одну грань, если она не лежит на ребре;
   - только в одну грань, если она лежит на ребре, являющемся мостом в графе;
   - точно в две грани, если она лежит на ребре, не являющемся мостом в графе.

## Теорема Эйлера для плоского графа

`Теорема Эйлера для плоского графа (формула Эйлера).`

Для всякого связного плоского графа выполняется следующее равенство:

$$
n-m+f=2
$$

 где $n,m,f$ - количество вершин, ребер, граней плоского графа.

**Доказательство.**

Пусть $G(X,U)$ – связный плоский $n,m$-граф, содержащий $f$ граней.

Построим для графа $G(X,U)$ его некоторое остовное дерево – граф $T$. Известно, что оличество ребер в этом дереве – $m(T) = n-1$, а количество граней в нем – $f(T) = 1$ (на основании утверждения №2).

Подставим значения в формулу Эйлера: $n-(n-1)+1=2$.

Следовательно, формула Эйлера верна для графа $T$.

Построим граф $G'$ путем добавления в дерево $T$ одного из новых ребер графа $G$, не вошедших в это дерево. Тогда $m(G')=m(T)+1=n$, а количество граней в нем $f(G')=f(T)+1=2$ (на основании свойства №3). Подставим значения в формулу Эйлера: $n-n+2=2$

Следовательно, формула Эйлера верна для графа $G'$.

Достроим цепочку графов $T \to G' \to G'' \to \cdots \to G$ до тех пор, пока не будет построен исходный граф $G$. Каждый следующий граф в цепи строится на основе предыдущего путем добавления в него нового ребра из графа $G$.

При проверке формулы Эйлера для очередного графа в цепочке заметим, что добавление нового ребра приводит к увеличению количества граней на 1. Таким образом, формула Эйлера верна и для графа $G$, завершающего эту цепочку.

## Следствия из теоремы Эйлера

1. Число граней в плоской укладке связного планарного $n,m$-графа определяется по формуле Эйлера как $f=m-n+2$, т.е. $f$ – инвариант планарного графа, не зависит от способа его плоской укладки.

**Утверждение.** Количество внутренних граней в связном планарном $n,m$-графе определяется цикломатическим числом этого графа, т.е. равно максимальному числу независимых циклов в графе.

По теореме Эйлера $n-m+f=2$ или $f-1=m-n+1$$$.

Известно, что для связного $n,m$-графа $\sigma(G)=m-n+1$. Любой плоский граф содержит точно одну внешнюю грань, поэтому $\sigma(G)$ совпадает с количеством внутренних граней в нем.

2. Для связного планарного $n,m$-графа при $n>3$ выполняется следующее условие:
   $$
   m\le3n-6
   $$

**Доказательство.**

Пусть $G$ – плоский граф без петель и кратных ребер.

Всякое ребро в нем – раздел двух граней или мост (свойство №4 плоских укладок).
Поэтому суммарное количество ребер во всех гранях этого графа - максимум $2m$.

Каждая грань в нем образована как минимум тремя ребрами. Поэтому суммарное количество ребер во всех гранях этого графа - минимум $3f$.

Следовательно, можно утверждать, что $3f \le 2m$.

Подставим в это неравенство $f=m-n+2$.
Тогда $3(m-n+2)\le2m$.
Отсюда и следует, что $m\le3n-6$

3. Полный 5-вершинный граф $K_5$ - непланарный граф.

**Доказательство** (от противного).

$$
m(K_5)=10, n(K_5)=5
$$

Предположим, что граф $K_5$ планарен.

Тогда для него должно выполняться условие $m\le3n-6$.

Но после подстановки значений получим, что $10\le3\cdot5-6$ (не верно).

Поэтому граф $K_5$ - непланарный граф.

4. Полный двудольный граф $K_{3,3}$ - непланарный граф.

**Доказательство** (от противного).

Предположим, что граф $K_{3,3}$ планарен.

Из-за двудольности графа каждая грань в нем образована как минимум 4 ребрами. Поэтому суммарное количество ребер во всех гранях этого графа - минимум $4f$. Следовательно, можно утверждать, что $4f \le 2m$. Подставим в это неравенство $f=m-n+2$. Тогда $m\le2n-4$.

Но после подстановки значений получим, что $9\le2\cdot6-4$ (не верно).

Поэтому граф $K_{3,3}$ - непланарный граф.

## Теорема Понтрягина-Куратовского (критерий планарности графа)

`Теорема Понтрягина-Куратовского (критерий планарности графа).`

Граф является планарным тогда и только тогда, когда в нем нет подграфов изоморфных и
(или) гомеоморфных графам $K_5$ и $K_{3,3}$.

**Примечание**: Графы $K_5$ и $K_{3,3}$ называют графами Понтрягина-Куратовского.

Задача плоской укладки графа решается следующим образом:

1. Исследование графа на планарность.
2. Если граф не планарный, то определяется минимальное количество слоев для его укладки.
3. Плоская укладка графа в слоях монтажного пространства.

## ⭐ Алгоритм плоской укладки планарного графа

Гамма-алгоритм решает задачу плоской укладки планарного $n,m$-графа $G$, т. е. исходный граф $G$ заведомо не содержит подграфов, изоморфных и (или) гомеоморфных графам $K_5$ и $K_{3,3}$. Отметим следующие особенности применения данного алгоритма.

1. Если граф $G$ является несвязным, то решается задача плоской укладки для каждой его компоненты связности данным алгоритмом. Решение задачи будет складываться из решений для каждой компоненты связности графа $G$.
2. Если граф $G$ – дерево, то задача плоской укладки является тривиальной, поэтому предполагается, что граф G содержит циклы.
3. Если граф $G$ – связный, но в нем есть хотя бы один мост, то решение с использованием данного алгоритма состоит из следующих этапов (согласно свойствам плоских укладок 1-3).
   1. Удаление мостов из графа $G$, в результате которого будет получен несвязный граф, содержащий компоненты связности $G_1, \dots, G_{k+1}$, где $k$ – количество мостов в графе $G$.
   2. Плоская укладка каждой компоненты связности с помощью гамма-алгоритма, в результате которой будут получен ряд плоских графов $G'_1, \dots, G'_{k+1}$, изоморфных графам $G_1, \dots, G_{k+1}$.
   3. Склейка плоских графов $G'_1, \dots, G'_{k+1}$ по общему ребру (мосту) следующим образом:
      - выбор первой пары плоских графов в ряду;
      - стереографическая проекция этих графов таким образом, чтобы грани, содержащие концы моста, стали внешними;
      - соединение концов моста кривой Жордана;
      - замена данной пары плоских графов в ряду на граф-склейку.
        Склейка продолжается до тех пор, пока ряд плоских графов $G'_1, \dots, G'_{k+1}$ не превратится в один плоский граф $G'$, изоморфный графу $G$.

Идея гамма-алгоритма заключается в том, что каждый простой цикл графа образует внутреннюю грань в его плоской укладке. Рассмотрим реализацию этого алгоритма для связного планарного графа $G$ с циклами и без мостов.

Алгоритм состоит из следующих шагов.

1. Вначале в графе $G$ выбирается любой простой цикл. На вершинах и ребрах этого цикла строится плоский граф G'. Очевидно, что плоский граф $G'$ содержит ровно две грани: $\Gamma_1$ – внешняя грань и $\Gamma_2$ – внутренняя грань.
2. Все остальные ребра графа G делятся на сегменты (обозначим множество полученных таким образом сегментов как $S$) следующим образом:
   - сегмент – ребро, оба конца которого лежат в множестве вершин графа $G'$;
   - сегмент – компонента связности, включающая ребра с инцидентными им вершинами (в каждой такой компоненте связности содержится не менее одной вершины из множества вершин графа $G'$).
3. Если $S = \emptyset$, то задача решена и граф $G'$ – плоская укладка графа $G$. Если $S \ne \emptyset$, то перейти к п.4.
4. Вершины сегментов, принадлежащие множеству вершин графа $G'$, определим как контактные. Для каждого сегмента $s \in S$ определим множество граней $\Gamma(s)$ графа $G'$, которым принадлежат его контактные вершины; подсчитаем их количество – $|\Gamma(s)|$. Очевидно, что $|\Gamma(s)| \le 2$.
5. Выберем сегмент $s \in S$ с минимальным ненулевым количеством граней $|\Gamma(s)|$, выделим в этом сегменте простую цепь с началом и концом из множества контактных вершин и внесем ее в граф $G'$; простая цепь при этом может быть и замкнутой. При этом могут быть следующие два варианта.
   - Если данный сегмент имеет только одну грань, то включаем его в эту грань следующим образом. Соединяем контактные вершины данного сегмента кривой Жордана, которая разобьет эту грань на две плоские грани (свойство №3 плоских укладок). Если в этом сегменте есть отличные от контактных вершин, то отобразим их в различные точки кривой Жордана согласно их связности.
   - Если данный сегмент имеет две грани, то то выбираем для его укладки первую по счету грань. Далее выполняем аналогичные действия по разбиению этой грани на две плоские грани.
6. В результате получим новый плоский граф $G'$. Удаляем сегмент, внесенный в граф $G'$, из множества $S$. Перейти к п. 3.

**Примечание**: Гамма-алгоритм корректен, т. е. для любого планарного $n,m$-графа $G$ он найдет плоскую укладку этого графа.
