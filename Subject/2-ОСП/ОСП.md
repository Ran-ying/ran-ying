ОСП

## 错误异常处理

- 将错误代码作为函数返回值传递
    - 一个常见的约定是函数的可能返回值之一是错误的指示
    - int 返回 -1
    - char * 返回 NULL
- 定义返回值类型枚举

    ```C
    typedef {
        NO_ERROR,
        ERROR_1,
    } error_t

    error_t func(){}
    error_t e = func();

    int func(error_t *e){}
    error_t e;
    int a = func(&e)

    if(e != NO_ERROR){}
    ```
- 标准库函数和错误处理
    - 不返回
    - 返回 -1
    - 返回 NULL
    - 大多数标准库函数将错误代码写入 errno 全局变量，错误代码在头文件 errno.h 中定义
        ```C
        extern int errno
        ```
- 显示错误信息
    ```C
    void perror(const char *errmsg);
    char* strerror(int errnum);
    perror(strerror(errno));
    ```

## 文件系统

- 使用文件
    - 系统调用（无缓冲 I/O）
        - open(),  close(), ...

        ```C
        int fd = open("hello.txt", O_RDONLY);
        if (fd < 0) {
        // Ошибка
        }
        else {
        // OK
        ...
        close(fd); // дескрипторы необходимо закрывать!
        }
        ```
        - read(), write(),
            -  从/向文件、套接字、管道等读取/写入数据的基本调用
            - 返回读取/写入的字节数或-1
            ```C
            #include <unistd.h>

            ssize_t read(int fd, void *buf, size_t count);
            ssize_t write(int fd, void *buf, size_t count);
            ```
        - lseek(), 
    - C标准库函数（缓冲I/O）
        - fopen(), fread(), fwrite(), fseek(), fclose(), ...
        ```C
        FILE *fp = fopen("hello.txt", "r");
        if (!fp) {
        // Ошибка
        }
        else {
        // OK
        ...
        fclose(fp); // Указатели на файлы необходимо закрывать!
        }
        ```
    - 系统调用与标准库函数相互转化
        - fd - FILE*
        ```C
        #include <stdio.h>
        FILE *fdopen(int fd, const char *mode);
        ```
        - FILE* - fd
        ```C
        #include <stdio.h>
        #define _POSIX_C_SOURCE

        int fileno(FILE *stream);
        ```
- 缓存 Управление буферизацией
```C
int setvbuf(FILE *stream, char *buffer,

int mode, size_t size)

...
char *buffer = (char*)malloc(1024*1024);
setvbuf(f, buffer, _IOFBF, 1024*1024);

...
setvbuf(f, NULL, _IONBF, 0);
```

- 使用 fgetch() 从文件中逐个字符读取并不像看起来那样低效，但在速度很重要的情况下，应使用 mmap()

- 逐行读取文件

    - 你可以使用 fgets()
        - 如果行很长，那么你无法阅读整行 - 不是灾难，但会造成不便
        - 需要多大的缓冲区？
    - 更易于使用getline()
        - 特别是因为它现在是 POSIX.1

- 目录
    - 遍历目录树
        - “复杂”选项
            - 用opendir()/readdir()递归遍历
        - “简单”选项
            - ftw() 或 ntfw()
            - fts_open()/fts_read()/fts_children()

## 内存管理

- 静态内存分配
    - 在文件级别（函数外）定义的变量成为全局变量
    - static 关键字允许你创建一个具有静态生命周期但局部作用域的变量
    ```C
    int global_var;
    int global_var_initialized = 42;

    int main() {
    int static static_var;
    // ...
    }
    ```
- 动态内存分配
    - 动态内存（堆）——数据段中的一块区域，程序在执行期间可以从这里接收内存
    ```C
    char *p = malloc(1024 * 1024 * 1024);
    ...
    free(p);
    ```
- 自动内存分配
    - C 中有 auto 和 register 关键字，但现在它们什么都不做：
    ```C
    auto int x = 42;
    register int y = 42;
    int z = 42;
    ```
    - 任何局部变量的空间都是从栈中分配的
    -  alloca() 函数允许你从栈中分配内存，当你退出调用所在的函数时，栈会自动释放
    ```C
    #include <alloca.h>
    ...
    int some_func() {
    ...
    char *p = alloca(256);
    ...
    // no need to call free(p);
    return 0;
    }
    ```
- 字符串文字和字符数组
```C
...
char str1[] = "by the pricking of my thumbs,";
char *str2 = "something wicked this way comes.";

printf("%s\n%s\n", str1, str2);

str1[0] = 'B';
str2[0] = 'S';

printf("%s\n%s\n", str1, str2); // ??
```

## 共享库

- 创建静态库
    ```C
    $ gcc –c file1.c ... fileN.c
    # produces file1.o ... fileN.o

    $ ar r libXXX.a file1.o ... fileN.o
    # creates libXXX.a
    ```
- 链接静态库
    ```C
    $ gcc –o example example.c libXXX.a
    # produces example
    ```

- 创建动态库
    ```C
    $ gcc –c –fPIC file1.c ... fileN.c
    # produces file1.o ... fileN.o

    $ gcc –shared –o libXXX.so file1.o ... fileN.o
    # creates libXXX.so

    $ gcc –shared –fPIC file1.c ... fileN.c
    ```
- 使用动态库构建程序
    ```C
    $ gcc –o example example.c -lXXX
    # сработает, если libXXX.so есть в одном из известных ld.so каталогов
    ```
- 手动装载动态库
    выполняется с помощью функций из libdl.so
    ```C
    #include <dlfcn.h>
    void *dlopen(const char *filename, int flags);
    void *dlsym(void *handle, const char *symbol);
    int dlclose(void *handle);
    ```
- 使用 LD_PRELOAD 加载共享库
- 动态库的版本
    ```C
    libXXX.so.maj.min.patch
    ```

    - могут состоять из нескольких компонентов:
        - maj – основная версия
        - min – дополнительная версия
        - patch – номер патча
    - обычно библиотека имеет:
        - real name
        - soname
        - linker name
- 搜索动态库 在 Linux 上，检查以下目录：
    - 列在DT_RPATH ELF文件属性中
    - 列在LD_LIBRARY_PATH环境变量中
        - setuid/setgid！
    - 列在ELF文件属性DT_RUNPATH
    - 从/etc/ld.so.cache缓存中获取
    - /lib
    - /usr/lin

## 多任务处理

- Термины
    - Параллелизм (parallelism) 并行 
    - Конкурентность (concurrency) 并发
    - Многозадачность (multitasking) 多任务处理
    - Многопроцессность (multiprocessing) 多程序
    - Многопоточность (multithreading) 多线程
    - Асинхронная обработка (anynchronous processing) 异步
- Linux 是一个通用的多用户多任务操作系统。
    - задача (task)
    - программа (program)
    - процесс (process)
    - поток (thread)
    - задание (job)
    - сессия (session)
    - группы
        - процессов (process groups)
        - потоков (thread groups)
- 创建新进程 fork
    ```C
    #include <sys/types.h>
    #include <unistd.h>

    pid_t fork(void);
    ```

    ```C
    pid_t child;
    if ((child = fork()) < 0) {
    // ошибка
    }
    else if (child == 0) {
    // внутри нового процесса
    }
    else {
    // внутри родительского
    // процесса
    }
    ```
- 进程识别
    - 进程ID和父进程ID可以使用getpid()和getppid()系统调用获取
    - 如果父进程先于子进程终止，则ID == 1 的进程成为新的父进程
    ```C
    #include <sys/types.h>
    #include <unistd.h>

    pid_t getpid(void);
    pid_t getppid(void);
    ```
- 在一个进程中启动一个新程序 exec()
    - 只有在发生错误时才可能从 exec() 返回
    - 进程ID不变
    - 可以将任意字符串传递给argv[0]
    ```C
    #include <unistd.h>

    int execv(const char *path, char *const argv[]);
    int execvp(const char *file, char *const argv[]);
    int execvpe(const char *file, char *const argv[], char *const envp[]);
    ```
- 终止进程
    - 正常情况下exit()
    - 如果子进程的exec()调用失败，则使用_exit()来避免重复刷新父进程中打开的文件缓冲区
    ```C
    #include <stdlib.h>
    void exit(int status);
    void _Exit(int status);
    void abort();

    #include <unistd.h>
    void _exit(int status);
    ```
- 注册析构函数
    - 使用 atexit() 和 on_exit()，您可以注册将在进程终止之前调用的函数（如果它是常规的）
    ```C
    #include <stdlib.h>

    int atexit(void (*function)(void));
    int on_exit(void (*function)(int, void*), void *arg);
    ```
- 获取进程的退出状态
    - 一个进程终止后，内核保存进程的终止状态和资源使用情况
    - 终止但其状态未被父进程接收的进程成为僵尸进程
- 等待终止
    - wait() 系统调用等待任何子进程的终止
    - 如果没有剩余的子进程，则返回 -1
    ```C
    #include <sys/types.h>
    #include <sys/wait.h>

    pid_t wait(int *wstatus);
    ```
    - waitpid() 系统调用等待任何**或给定**子进程的终止
    ```C
    #include <sys/types.h>
    #include <sys/wait.h>

    pid_t waitpid(pid_t pid, int *wstatus, int options);
    ```
    pid < -1 - 等待组 ID 为 pid 的进程终止
    pid = -1 - 等待任何生成的进程终止
    pid = 0 - 等待任何具有父组 ID 的进程终止
    pid > 0 - 等待给定 pid 的进程结束
    - wait3() 和 wait4() 系统调用允许您获取有关子进程已消耗资源的信息：
    ```C
    #include <sys/types.h>
    #include <sys/time.h>
    #include <sys/resource.h>
    #include <sys/wait.h>

    pid_t wait3(int *wstatus, int options,
    struct rusage *rusage);

    pid_t wait4(pid_t pid, int *wstatus, int options,
    struct rusage *rusage);
    ```
- 在 Linux 中启动进程的其他方法
    - system
    ```C
    #include <stdlib.h>
    int system(const char *command);
    ```
    - popen
    ```C
    #include <stdio.h>
    FILE *popen(const char *command, const char *type);
    int pclose(FILE *stream);
    ```
    - posix_spawn
    ```C
    #include <spawn.h>
    int posix_spawn(pid_t *pid, const char *path,

    const posix_spawn_file_actions_t *file_actions,
    const posix_spawnattr_t *attrp,
    char *const argv[], char *const envp[]);
    ```
- 进程监控和跟踪
    - Мониторинг процессов
        - ps, top, htop, btop, ...
        - lsof
        - iotop

## 线程和同步

- 创建线程
```C
#include <pthread.h>

int pthread_create(pthread_t *thread,
const pthread_attr_t *attr,
void *(*start_routine) (void *),
void *arg);
```

- 结束线程

    - 如果出现以下情况，线程将结束：
        - 流函数返回
        - 线程调用pthread_exit()或exit()
        - 通过调用pthread_cancel()取消线程
        - 通过调用 exit() 或从 main() 返回来终止主线程
            - 如果使用 pthread_exit() 发生终止，则子线程继续工作

    - 如果一个线程调用了exit(), _exit(), 或者_Exit()，那么整个进程就结束了！

- 加入线程
    - 一个线程结束后运行另一个
    ```C
    #include <pthread.h>
    int pthread_join(pthread_t thread, void **retval);
    ```

- 分离线程
    ```C
    #include <pthread.h>

    int pthread_detach(pthread_t thread);
    ```

- 分离并结束线程
    ```C
    #define _GNU_SOURCE
    #include <pthread.h>

    int pthread_tryjoin_np(pthread_t thread,

    void **retval);

    int pthread_timedjoin_np(pthread_t thread,

    void **retval,
    const struct timespec *abstime);
    ```

- 取消线程
    ```C
    #include <pthread.h>

    int pthread_cancel(pthread_t thread);

    void pthread_testcancel(void);
    ```
- 线程和信号
    ```C
    #include <signal.h>

    int pthread_sigmask(int how,
    const sigset_t *set,
    sigset_t *oldset);
    ```
- 向线程发送信号
    ```C
    #include <signal.h>

    int pthread_kill(pthread_t thread, int sig);
    ```
- 线程终止清理函数
    ```C
    #include <pthread.h>

    void pthread_cleanup_push(
    void (*routine)(void *),
    void *arg);

    void pthread_cleanup_pop(int execute);
    ```
- 线程同步工具
    - pthread 库中的同步工具
        - 循环锁（自旋锁）(spinlocks)
        - 互斥量 (mutexes)
        - 信号量 (semaphores)
        - 条件变量 (condition variables)
        - 读写锁 (read-write locks)
        - 障碍 (barriers)
- 同步的一般模式
    ```C
    // Захват (блокировка)
    // примитива синхронизации
    lock();

    ...
    // Критическая секция
    ...

    // Освобождение (разблокирование)
    // примитива синхронизации
    unlock();
    ```
- 循环阻塞 Циклическая блокировка

    ```C
    #include <pthread.h>

    int pthread_spin_init(
    pthread_spinlock_t *lock,
    int pshared);

    int pthread_spin_destroy(
    pthread_spinlock_t *lock);

    int pthread_spin_lock(
    pthread_spinlock_t *lock);

    int pthread_spin_trylock(
    pthread_spinlock_t *lock);

    int pthread_spin_unlock(
    pthread_spinlock_t *lock);
    ```
- 互斥阻塞 Мьютексы
    ```C
    #include <pthread.h>

    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

    int pthread_mutex_init(
    pthread_mutex_t *mutex, pthread_mutexattr_t
    *attr);

    int pthread_mutex_destroy(
    pthread_mutex_t *mutex);

    int pthread_mutex_lock(
    pthread_mutex_t *mutex);

    int pthread_mutex_trylock(
    pthread_mutex_t *mutex);

    int pthread_mutex_unlock(
    pthread_mutex_t *mutex);
    ```

- 条件变量
    ```C
    #include <pthread.h>

    pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

    int pthread_cond_init(
    pthread_cond_t *cond,
    pthread_condattr_t *condattr);

    int pthread_cond_destroy(
    pthread_cond_t *cond);

    int pthread_cond_wait(
    pthread_cond_t *cond,
    pthread_mutex_t *mutex);

    int pthread_cond_timedwait(
    pthread_cond_t *cond,
    pthread_mutex_t *mutex,
    struct timespec *expiration);
    ```
- 读写锁
    ```C
    #include <pthread.h>

    pthread_rwlock_t rwlock =
    PTHREAD_RWLOCK_INITIALIZER;

    int pthread_rwlock_init(
    pthread_rwlock_t *rwlock,
    const pthread_rwlockattr_t *attr);

    int pthread_rwlock_destroy(
    pthread_rwlock_t *rwlock);

    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);

    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);

    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
    ```
## 进程间通信 - 信号

- 信号是对事件已发生的进程的异步通知。
- 信号源可以是：
    - 操作系统内核
    - kill() 系统调用允许您向给定进程发送信号：
    ```C
    #include <sys/types.h>
    #include <signal.h>

    int kill(pid_t pid, int sig);
    ```
    - 终端
    ```C
    kill –l
    // 显示系统中可用的信号列表
    kill -N pid
    kill -NAME pid
    // 向具有给定pid的进程发送信号
    ```
    - raise() 标准库函数允许进程向自己发送信号：
    ```C
    #include <signal.h>

    int raise(int sig);
    ```
- Signal() 标准库函数在程序中处理信号
    ```C
    #include <signal.h>

    void (*signal(int signum, void (*handler)(int)))(int);

    typedef void (*sighandler_t)(int);
    sighandler_t signal(int signum, sighandler_t handler);
    ```
- 中断系统调用
    ```C
    do {
    n = read(fd, buf, sizeof(buf));
    // обработать прочитанные n байтов
    } while (n < 0 && IS_EINTR(errno));


    int res = TEMP_FAILURE_RETRY(read(fd, buf, sizeof(buf)));
    ```
- POSIX 信号处理
    ```C
    #include <signal.h>

    int sigemptyset(sigset_t *set);
    int sigfillset(sigset_t *set);
    int sigaddset(sigset_t *set, int signum);
    int sigdelset(sigset_t *set, int signum);
    int sigismember(const sigset_t *set, int signum);
    ```
- 设置信号掩码
    ```C
    #include <signal.h>
    int sigprocmask(
    int how,
    const sigset_t *set,
    sigset_t *oldset);
    ```
- 确定阻塞信号的掩码
    ```C
    #include <signal.h>

    int sigpending(sigset_t *set);
    ```
- 安装信号处理程序
    ```C
    #include <signal.h>
    int sigaction(int signum,

    const struct sigaction *act,
    struct sigaction *oldact);

    struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t*, void*);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
    };
    ```
- 拓展处理程序
    ```C
    void SIG_handler(int signum,

    siginfo_t *info,
    void *ctx) {

    ...
    }
    ```
- 实时信号
    ```C
    union sigval {
    int sival_int;
    void *sival_ptr;
    };
    ```
- 发送实时信号
    ```C
    #include <signal.h>

    int sigqueue(pid_t pid,
    int sig,
    const union sigval value);
    ```
## 进程间通信 - 管道
- 匿名管道 Безымянные каналы
    ```C
    #include <unistd.h>

    int pipe(int pipefd[2]);

    pipefd[0] – открыт для чтения
    pipefd[1] – открыт для записи
    ```
- 命名管道
    ```C
    #include <sys/types.h>
    #include <sys/stat.h>

    int mkfifo(const char *pathname, mode_t mode);
    ```
- 创建管道
    ```
    > echo "hi there" | sed s/hi/hello/g
    ```
- 描述符重复
    ```C
    #include <unistd.h>

    int dup(int oldfd);
    int dup2(int oldfd, int newfd);
    ```
- 管理文件属性
    - fcntl()
    ```C
    #include <unistd.h>
    #include <fcntl.h>

    int fcntl(int fd, int cmd, ... );
    ```
    - 描述符重复
    ```C
    int newfd = fcntl(oldfd, F_DUPFD, 0);
    ```
    - 切换到非阻塞模式
    ```C
    ...
    int flags = fcntl(fd, F_GETFL);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
    ```
## 进程间通信 - 共享内存
- mmap() 系统调用用于将文件映射到内存中。
    ```C
    #include <sys/mman.h>
    //打开
    void *mmap(
        void *addr,
        size_t length,
        int prot,
        int flags,
        int fd,
        off_t offset);

    //关闭
    int munmap(void *addr, size_t length);
    ```
## 进程间通信 - 套接字
- 地址结构
    ```C
    #include <netinet/in.h>

    struct sockaddr_in {
    uint8_t sin_len;
    sa_family_t sin_family;
    in_port_t sin_port
    struct in_addr sin_addr;
    char sin_zero[8];
    };

    struct in_addr {
    in_addr_t s_addr;
    };
    ```
- 广义地址结构
    ```C
    #include <sys/socket.h>

    struct sockaddr {
    uint8_t sa_len;
    sa_family_t sa_family;
    char sa_data[14];
    };
    ```
- s_addr 字段的值
    ```C
    struct sockaddr_in addr = {0};

    ...
    addr.sin_addr.s_addr =
    htonl(INADDR_LOOPBACK);
    ```
    - INADDR_ANY
        - все адреса локального хоста (0.0.0.0)
    - INADDR_LOOPBACK
        - адрес loopback интерфейса (127.0.0.1)
    - INADDR_BROADCAST
        - широковещательный адрес (255.255.255.255)
- 地址转换
    ```C
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>

    int inet_aton(const char *cp, struct in_addr *inp);

    in_addr_t inet_addr(const char *cp);

    char *inet_ntoa(struct in_addr in);
    ```
- 创建套接字
    ```C
    #include <sys/types.h
    #include <sys/socket.h>

    int socket(int domain, int type, int protocol);
    ```
- 连接套接字
    ```C
    #include <sys/types.h>
    #include <sys/socket.h>

    int connect(int sockfd,

    const struct sockaddr *addr,
    socklen_t addrlen);
    ```
- 将套接字绑定到地址
    ```C
    #include <sys/types.h
    #include <sys/socket.h>

    int bind(int sockfd,

    const struct sockaddr *addr,
    socklen_t addrlen);
    ```
- 将套接字切换到“监听”模式
    ```C
    #include <sys/types.h
    #include <sys/socket.h>

    int listen(int sockfd, int backlog);
    ```
- 等待传入连接
    ```C
    #include <sys/types.h
    #include <sys/socket.h>

    int accept(int sockfd,

    struct sockaddr *addr,
    socklen_t *addrlen);
    ```
- 获取对方信息
    ```C
    #include <sys/socket.h>

    int getpeername(int sockfd,
    struct sockaddr *addr,
    socklen_t *addrlen);
    ```
- UDP 收发
    ```C
    #include <sys/types.h>
    #include <sys/socket.h>

    ssize_t sendto(int sockfd,

    const void *buf, size_t len, int flags,
    const struct sockaddr *dest_addr,
    socklen_t addrlen);

    ssize_t recvfrom(int sockfd,

    void *buf, size_t len, int flags,
    struct sockaddr *src_addr,
    socklen_t *addrlen);
    ```
- 检查服务器消息
    ```C
    int res = sendto(clientSocket, buffer,
    strlen(buffer), 0,
    (const struct sockaddr*)&serverAddr,
    sizeof(serverAddr));

    ...

    res = recvfrom(clientSocket, buffer,
    sizeof(buffer), 0, replyAddr, &len);

    if (len == sizeof(serverAddr) &&
    memcmp(serverAddr, replyAddr, len) == 0) {
    // reply from the server we sent request to
    }
    ```
## 非阻塞 I/O 和多路复用 I/O
    ```C
    ```

    ```C
    ```

    ```C
    ```